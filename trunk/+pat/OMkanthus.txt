(in-package :om);;;;; GLOBAL VARIABLES(defvar *kh_note_counter* 0    "")(defvar *kh_node_counter* 0    "")(defvar *kh_cyclic_counter* 0    "")(defvar *kh_occurrence_counter* 0    "")(defvar *kh_meta* 0    "")(defvar *kh_print* 0    "")(defvar *kh_notes* 0    "")(defvar *kh_root* 0   "");;;;; CLASSES(defclass kh_object ()   ((kh_address :type integer :accessor kh_address :initarg :kh_address)))(defclass kh_signed_number ()   ((kh_number :type integer :accessor kh_number :initarg :kh_number)    (kh_sign :type t :accessor kh_sign :initarg :kh_sign)))(defclass kh_description ()   ((kh_interpitch :type t :accessor kh_interpitch :initarg :kh_interpitch :initform nil)    (kh_interdegree :type t :accessor kh_interdegree :initarg :kh_interdegree :initform nil)    (kh_metric :type t :accessor kh_metric :initarg :kh_metric :initform nil)    (kh_interonset :type number :accessor kh_interonset :initarg :kh_interonset :initform nil)    (kh_pitch :type t :accessor kh_pitch :initarg :kh_pitch :initform nil)    ))(defmethod kh_inter_description ((o t))   (make-instance 'kh_description     :kh_interpitch (kh_interpitch o)     :kh_interdegree (kh_interdegree o)     :kh_interonset (kh_interonset o)))(defmethod kh_note_description ((o t))   (make-instance 'kh_description     :kh_metric (kh_metric o)     :kh_pitch (kh_pitch o)))(defun kh_intersect_description (m n)   (make-instance 'kh_description     :kh_interpitch (and (kh_interpitch m)                         (kh_interpitch n)                         (if (equal (kh_sign (kh_interpitch m)) (kh_sign (kh_interpitch n)))                           (if (equal (kh_number (kh_interpitch m)) (kh_number (kh_interpitch n)))                             (kh_interpitch m)                             (and *kh_contour*                                  (kh_sign (kh_interpitch m))))                           (and nil                                (equal (kh_number (kh_interpitch m)) (kh_number (kh_interpitch n)))                                (kh_number (kh_interpitch m)))))     :kh_interdegree (and (kh_equal (kh_interdegree m) (kh_interdegree n))                          (kh_interdegree m))     :kh_interonset (and (equal (kh_interonset m) (kh_interonset n))                         (kh_interonset m))     :kh_metric (and (equal (kh_metric m) (kh_metric n))                     (kh_metric m))     :kh_pitch (and (equal (kh_pitch m) (kh_pitch n))                    (kh_pitch m))     ))(defmethod kh_description ((n t))  (print "WARNING!WARNING!WARNING!WARNING!:: kh_description nil")  nil)(defclass kh_pattern (kh_object)   ((kh_last :type t :accessor kh_last :initform nil :initarg :kh_last)    (kh_description :type kh_description :accessor kh_description :initarg :kh_description :initform (make-instance 'kh_description))    (kh_occurrence :type list :accessor kh_occurrence :initform nil)    (kh_acyclic_children :type list :accessor kh_acyclic_children :initform nil)    (kh_cyclic_children :type list :accessor kh_cyclic_children :initform nil)    (kh_interpitch_associative_memory :type t :accessor kh_interpitch_associative_memory :initform (make-hash-table))    (kh_interdegree_associative_memory :type t :accessor kh_interdegree_associative_memory :initform (make-hash-table))    (kh_contour_associative_memory :type t :accessor kh_contour_associative_memory :initform (make-hash-table))    (kh_interonset_associative_memory :type t :accessor kh_interonset_associative_memory :initform (make-hash-table))    (kh_metric_associative_memory :type t :accessor kh_metric_associative_memory :initform (make-hash-table))    (kh_pitch_associative_memory :type t :accessor kh_pitch_associative_memory :initform (make-hash-table))    (kh_general :type list :accessor kh_general :initarg :kh_general :initform nil)    (kh_specific :type list :accessor kh_specific :initarg :kh_specific :initform nil)))(defclass kh_cyclic_pattern (kh_pattern)   ((kh_cycle_frame :type t :accessor kh_cycle_frame :initarg :kh_cycle_frame :initform nil)    (kh_general_cycle :type list :accessor kh_general_cycle :initarg :kh_general_cycle :initform nil)    (kh_specific_cycle :type list :accessor kh_specific_cycle :initarg :kh_specific_cycle :initform nil)    (kh_next :type t :accessor kh_next :initarg :kh:next :initform nil)    (kh_specific_next :type t :accessor kh_specific_next :initarg :kh_specific_next :initform nil)    (kh_pos :type t :accessor kh_pos :initarg :kh_pos)    (kh_acyclic_last :accessor kh_acyclic_last :initarg :kh_acyclic_last :initform nil)))(defclass kh_temporal_object (kh_object)   ((kh_from :type list :accessor kh_from :initform nil)    (kh_to :type list :accessor kh_to :initform nil)    (kh_node :type kh_pattern :accessor kh_node :initarg :kh_node)    (kh_upto :type list :accessor kh_upto :initform nil)))(defclass kh_occurrence (kh_temporal_object)   ((kh_last :type t :accessor kh_last :initarg :kh_last :initform nil)        (kh_relation :type t :accessor kh_relation :initarg :kh_relation :initform nil)    (kh_next :type list :accessor kh_next :initform nil)    (kh_general :type list :accessor kh_general :initarg :kh_general :initform nil)    (kh_specific :type list :accessor kh_specific :initarg :kh_specific :initform nil)    (kh_new :type t :accessor kh_new :initarg :kh_new :initform nil)    ))(defmethod kh_param ((o kh_occurrence))   (kh_to (kh_relation o)))(defclass kh_syntagmatic_relation ()   ((kh_from :type kh_from :accessor kh_from :initarg :kh_from)    (kh_to :type kh_to :accessor kh_to :initarg :kh_to)))(defclass kh_note (kh_temporal_object)   ((kh_chroma :type integer :accessor kh_chroma :initarg :kh_chroma)    (kh_degree :type integer :accessor kh_degree :initarg :kh_degree :initform nil)    (kh_interdegree :type integer :accessor kh_interdegree :initarg :kh_interdegree :initform nil)    (kh_interpitch :type integer :accessor kh_interpitch :initarg :kh_interpitch :initform nil)    (kh_duration :type integer :accessor kh_duration :initarg :kh_duration)    (kh_time :type integer :accessor kh_time :initarg :kh_time)    (kh_metric :type integer :accessor kh_metric :initarg :kh_metric)));;;;; METHODS(defmethod kh_cyclicp ((p kh_cyclic_pattern))   t)(defmethod kh_cyclicp ((p kh_pattern))   nil)(defmethod kh_cyclicp ((o kh_occurrence))   (kh_cyclicp (kh_node o)))(defmethod kh_pitch ((n kh_note))   (kh_chroma n))(defmethod kh_equal ((d kh_signed_number) (e kh_signed_number))   (and d        e        (equal (kh_sign d) (kh_sign e))        (equal (kh_number d) (kh_number e))))(defmethod kh_equal ((d kh_signed_number) (e number))   ;(print "kh_equal")   ;(print d)   ;(print e)   (and d        e        (or (not (kh_sign d))            (kh_same_contour (kh_sign d) e))        (or (not (kh_number d))            (= (kh_number d) (abs e)))))(defmethod kh_equal ((d kh_signed_number) (e t))   nil)(defmethod kh_equal ((d number) (e kh_signed_number))   (kh_equal e d))(defmethod kh_equal ((d t) (e kh_signed_number))   nil)(defmethod kh_equal ((d number) (e number))   (equal d e))(defmethod kh_equal ((d t) (e t))   t)(defmethod kh_equal ((d function) (e function))   (equal d e))(defmethod kh_equal ((d function) (e t))   nil)(defmethod kh_equal ((d t) (e function))   nil)(defmethod kh_equal ((d function) (e kh_signed_number))   (and (not (kh_number e))        (equal d (kh_sign e))))(defmethod kh_equal ((d kh_signed_number) (e function))   (and (not (kh_number d))        (equal e (kh_sign d))))(defmethod kh_equal_or_specific ((d kh_signed_number) (e kh_signed_number))   (and (or (not e)            (not (kh_sign e))            (equal (kh_sign e) (kh_sign d)))        (or (not e)            (not (kh_number e))            (equal (kh_number e) (kh_number d)))))(defmethod kh_equal_or_specific ((d integer) (e kh_signed_number))   (and (or (not e)            (not (kh_sign e))            (kh_same_contour (kh_sign e) d))        (or (not e)            (not (kh_number e))            (= (kh_number e) (abs d)))))(defmethod kh_equal_or_specific ((d t) (e kh_signed_number))   nil)(defmethod kh_equal_or_specific ((d function) (e function))   (equal d e))(defmethod kh_equal_or_specific ((d kh_signed_number) (e function))   (equal e (kh_sign d)))(defmethod kh_equal_or_specific ((d function) (e t))   t)(defmethod kh_equal_or_specific ((d function) (e number))   nil)(defmethod kh_equal_or_specific ((d t) (e function))   nil)(defmethod kh_equal_or_specific ((d t) (e t))  (print "WARNING!WARNING!WARNING!WARNING!:: kh_equal_or_specific nil")   nil)(defmethod kh_equal_or_specific ((d function) (e kh_signed_number))   (kh_equal d e))(defmethod kh_sign_number ((n number))   (make-instance 'kh_signed_number     :kh_sign (kh_contour n)     :kh_number (abs n)))(defmethod kh_nil ((d kh_description) (n t))   ;(print "kh_nil?")      ;(kh_print d)   ;(kh_print n)   (not (or (and (kh_interpitch d)                 (or (not (typep (kh_interpitch d) 'kh_signed_number))                     (or (kh_number (kh_interpitch d))                         (kh_sign (kh_interpitch d)))))            (and (kh_interdegree d)                 (or (not (typep (kh_interdegree d) 'kh_signed_number))                     (or (kh_number (kh_interdegree d))                         (kh_sign (kh_interdegree d)))))            (and (kh_metric d)                 (or                   (equal n *kh_root*)                  (kh_interonset d)))            (kh_interonset d) ;a enlever si on veut dependance a la metrique            #|(and (kh_pitch d)                 (or (not n)                     ;(equal n *kh_root*)                     (not (equal n *kh_note*))                     ))|#            )))(defmethod kh_equal ((d kh_description) (e kh_description))   ;(print "kh_equal")   ;(kh_print d)   ;(kh_print e)   (and (kh_equal (kh_interpitch d) (kh_interpitch e))        (kh_equal (kh_interdegree d) (kh_interdegree e))        (equal (kh_interonset d) (kh_interonset e))        (equal (kh_metric d) (kh_metric e))        (equal (kh_pitch d) (kh_pitch e))))(defmethod kh_equal_or_specific ((d kh_description) (e kh_description))   ;(print "kh_equal_or_specific")   ;(print d)   ;(print e)   (and (or (not (kh_interpitch e))            (kh_equal_or_specific (kh_interpitch d) (kh_interpitch e)))        (or (not (kh_interdegree e))            (kh_equal_or_specific (kh_interdegree d) (kh_interdegree e)))        (or (not (kh_interonset e))            (equal (kh_interonset d) (kh_interonset e)))        (or (not (kh_metric e))            (equal (kh_metric d) (kh_metric e)))        (or (not (kh_pitch e))            (equal (kh_pitch d) (kh_pitch e)))))(defmethod kh_more_specific ((d t) (e t))   (and (kh_equal_or_specific d e))   (not (kh_equal d e)))(defmethod kh_equal_or_less_specific ((d t) (e t))   (kh_equal_or_specific e d))(defmethod kh_less_specific ((d t) (e t))   (and (kh_equal_or_less_specific d e))   (not (kh_equal d e)))(defmethod kh_match ((r kh_description) (n kh_description))   (kh_filter (make-instance 'kh_description                  :kh_interpitch (and (kh_interpitch n)                                      ;(kh_equal (kh_interpitch n) (kh_interpitch r))                                      (kh_interpitch r)                                      (or *kh_transpos*                                          (and (kh_pitch n) (equal (kh_pitch n) (kh_pitch r))))                                      ;#|                                      (make-instance 'kh_signed_number                                        :kh_number (and (kh_number (kh_interpitch n))                                                        (equal (kh_number (kh_interpitch n)) (kh_number (kh_interpitch r)))                                                        (kh_number (kh_interpitch n)))                                        :kh_sign (and (kh_sign (kh_interpitch n))                                                      (equal (kh_sign (kh_interpitch n)) (kh_sign (kh_interpitch r)))                                                      (kh_sign (kh_interpitch n))))                                      ;|#                                      )                  :kh_interdegree (and (kh_interdegree n)                                       (kh_interdegree r)                                       (or *kh_transpos*                                           (and (kh_pitch n) (equal (kh_pitch n) (kh_pitch r))))                                       (make-instance 'kh_signed_number                                         :kh_number (and (kh_number (kh_interdegree n))                                                         (equal (kh_number (kh_interdegree n)) (kh_number (kh_interdegree r)))                                                         (kh_number (kh_interdegree n)))                                         :kh_sign (and (kh_sign (kh_interdegree n))                                                       (equal (kh_sign (kh_interdegree n)) (kh_sign (kh_interdegree r)))                                                       (kh_sign (kh_interdegree n)))))                  :kh_interonset (and (kh_interonset n)                                      (equal (kh_interonset n) (kh_interonset r))                                      (kh_interonset n))                  :kh_metric (and (kh_metric n)                                  (equal (kh_metric n) (kh_metric r))                                  (kh_metric n))                  :kh_pitch (and (kh_pitch n)                                 (equal (kh_pitch n) (kh_pitch r))                                 (kh_pitch n)))))(defmethod kh_cumul ((d kh_description) (e kh_description))   (make-instance 'kh_description     :kh_interpitch (kh_cumul (kh_interpitch d) (kh_interpitch e))     :kh_interdegree (kh_cumul (kh_interdegree d) (kh_interdegree e))     :kh_interonset (kh_cumul (kh_interonset d) (kh_interonset e))))(defmethod kh_relative_number ((n kh_signed_number))   (and (kh_number n)        (* (kh_number n)           (if (equal (kh_sign n) #'kh_descending)             -1             1))))(defmethod kh_cumul ((i kh_signed_number) (j kh_signed_number))   (and (kh_number i) (kh_number j)        (let ((res (+ (kh_relative_number i) (kh_relative_number j))))          (make-instance 'kh_signed_number            :kh_number (abs res)            :kh_sign (if (> res 0)                       #'kh_ascending                       (if (< res 0)                         #'kh_descending                         #'kh_constant))))))(defmethod kh_cumul ((i integer) (j integer))   (+ i j))(defmethod kh_cumul ((i kh_signed_number) (j integer))   (and (kh_number i)        (let ((res (+ (kh_relative_number i) j)))          (make-instance 'kh_signed_number            :kh_number (abs res)            :kh_sign (if (> res 0)                       #'kh_ascending                       (if (< res 0)                         #'kh_descending                         #'kh_constant))))))(defmethod kh_cumul ((i integer) (j kh_signed_number))   (and (kh_number j)        (let ((res (+ i (kh_relative_number j))))          (make-instance 'kh_signed_number            :kh_number (abs res)            :kh_sign (if (> res 0)                       #'kh_ascending                       (if (< res 0)                         #'kh_descending                         #'kh_constant))))))(defmethod kh_cumul ((i t) (j t))   or i j)(defmethod kh_children ((pattern kh_pattern))   (append (kh_acyclic_children pattern)           (kh_cyclic_children pattern)))(defmethod kh_level ((pattern kh_pattern))   (labels ((recurs_level (p l)              (if (kh_last p)                (if (member (kh_last p) l)                  1                  (1+ (recurs_level (kh_last p) (cons (kh_last p) l))))                0)))     (recurs_level pattern (list pattern))))(defmethod kh_count ((pattern kh_pattern))   ;(print "kh_count")   ;(kh_print pattern)   (labels ((recurs_count (p l i)              (and p                   (if (member p l)                     (recurs_count (kh_cycle_frame p) l i)                     ;(list (1+ i) i)                     (append (recurs_count (kh_last p) (cons p l) (1+ i)) (list i))))))     (recurs_count pattern nil 0)))(defmethod kh_acyclic_level ((pattern kh_pattern))   (if (kh_last pattern)     (1+ (kh_acyclic_level (kh_last pattern)))     0))(defmethod kh_acyclic_level ((pattern kh_cyclic_pattern))   (* (kh_level pattern) 2))(defmethod kh_all_specific_cycle ((node kh_cyclic_pattern))   (loop for s in (kh_specific_cycle node)         append (cons s (kh_all_specific_cycle s))))(defmethod kh_equal ((o kh_pattern) (p kh_pattern))   (equal o p))(defmethod kh_interpitch ((pattern kh_pattern))   (kh_interpitch (kh_description pattern)))(defmethod kh_interdegree ((pattern kh_pattern))   (kh_interdegree (kh_description pattern)))(defmethod kh_contour ((pattern kh_pattern))   (kh_contour (kh_description pattern)))(defmethod kh_interonset ((pattern kh_pattern))   (kh_interonset (kh_description pattern)))(defmethod kh_metric ((pattern kh_pattern))   (kh_metric (kh_description pattern)))(defmethod kh_pitch ((pattern kh_pattern))   (kh_pitch (kh_description pattern)))(defmethod kh_equal_or_specific ((o kh_pattern) (p kh_pattern))  ; IL PEUT Y AVOIR PLUSIEURS POSSIBILITES!   (let ((condition (and (= (kh_address (car *kh_notes*)) 0)                         (= (kh_address o) 3)                         (= (kh_address p) 9)                         (kh_cyclicp o)                         (not (kh_cyclicp p))                         )))     (and condition          (print "kh_equal_or_specific")          (not (kh_print o))          (kh_print p))     (or (and (or (equal o p)                  (equal p *kh_root*))              (kh_count o))         (labels ((recurs_cumul (i j l m a b c k)                    (and condition                         (progn                           (print "recurs_cumul")                           (not (kh_print i))                           (not (kh_print j))                           (print a)                           (print b)                           (kh_print c)))                    (if b                      (list k)                      (and (not a)                           (or (and (kh_equal_or_specific c (kh_inter_description j))                                    (if (or (not (kh_last j))                                            (equal (kh_last j) *kh_root*)                                            (and a b))                                      t ;(list k)                                      (and (not (equal (kh_last i) *kh_root*))                                           (let ((res (recurs_equal_or_specific (kh_last i) (kh_last j)                                                                                (cons i l) (cons j m)                                                                                (or a (member i ;(cdr (member i ; i should be twice in l                                                                                              l                                                                                              ;))                                                                                              ))                                                                                (or b (member j ;(cdr (member j ; idem                                                                                              m                                                                                              ;))                                                                                              ))                                                                                (1+ k))))                                             (and res                                                  ;(cons k res)                                                  res)))))                               (and *kh_graph*                                    (kh_last i)                                    (recurs_cumul (kh_last i) j                                                  (cons i l) m                                                  (or a (member i ;(cdr (member i ; i should be twice in l                                                                l                                                                ;))                                                                ))                                                  b                                                  (kh_cumul c (kh_inter_description (kh_last i)))                                                  (1+ k)))))))                  (recurs_equal_or_specific (i j l m a b k)                    (and condition                         (progn                           (print "recurs_equal_or_specific1")                           (not (kh_print i))                           (not (kh_print j))                           (print l)                           (print m)                           (print a)                           (print b)))                    (and i                         (kh_last i)                         (if b                           (list k)                           (and (not a)                                (if condition                                  (progn                                    (kh_print (kh_note_description i))                                    (kh_print (kh_note_description j))                                    (print (kh_equal_or_specific (kh_note_description i) (kh_note_description j)))                                    t)                                  t)                                (kh_equal_or_specific (kh_note_description i) (kh_note_description j))                                (let ((cum (recurs_cumul i j l m a b (kh_inter_description i) k)))                                  (and cum                                       (if (equal cum t)                                         (list k)                                         (cons k cum))))                                )))))           (let ((res (recurs_equal_or_specific o p nil nil nil nil 0)))             (and res                  (progn (and condition                          (print "kh_equal_or_specific")                          (not (kh_print o))                          (not (kh_print p))                          (reverse (print res))) ;(cons 0 res))))                         (reverse res)))))))) ;(cons 0 res)))))))))(defmethod kh_equal_or_specific ((o kh_occurrence) (p kh_occurrence))   (let ((condition (and nil                         (= (kh_address o) 73)                         (= (kh_address p) 72))))     (and condition          (progn            (print "kh_equal_or_specific")            (kh_print o)            (kh_print p)))     (or (equal o p)            (labels ((recurs_cumul (i j c)                    (and condition                         (progn                           (print "recurs_cumul")                           (kh_print i)                           (kh_print j)                           (kh_print c)))                    (or (and (kh_equal_or_specific c (kh_inter_description (kh_node (car j))))                             (or (not (cdr j))                                 ;(equal (kh_last (kh_node (car j))) *kh_root*)                                 (and (cdr i)                                      ;(not (equal (kh_last (kh_node (car i))) *kh_root*))                                      (recurs_equal_or_specific (cdr i) (cdr j)))))                        (and (cdr i)                             ;(not (equal (kh_last (kh_node (car i))) *kh_root*))                             (recurs_cumul (cdr i) j                                           (kh_cumul c (kh_inter_description (kh_node (cadr i))))))))                  (recurs_equal_or_specific (i j)                    (and condition                         (progn                           (print "recurs_equal_or_specific2")                           (kh_print i)                           (kh_print j)))                    (and (equal (kh_param (car i)) (kh_param (car j)))                         (kh_equal_or_specific (kh_note_description (kh_node (car i))) (kh_note_description (kh_node (car j))))                         (recurs_cumul i j (kh_inter_description (kh_node (car i)))))))           (recurs_equal_or_specific (reverse (kh_enumerate o)) (reverse (kh_enumerate p)))))))(defmethod kh_equal_or_specific ((o kh_occurrence) (p kh_pattern))   (and (= (kh_address o) 0)        (print "kh_equal_or_specific")        (not (kh_print o))        (kh_print p))   (or (equal p *kh_root*)       (equal (kh_node o) p)          (labels ((recurs_cumul (i j m b c k)                  ;(progn                  ;(print "recurs_cumul3")                  ;(not (kh_print i))                  ;(kh_print j)                  ;(print m)                  ;(print b))                  (if b                    (list k)                    (or (and (kh_equal_or_specific c (kh_inter_description j))                             (if (equal (kh_last j) *kh_root*)                               (list k)                               (and (kh_last i)                                    (let ((res (recurs_equal_or_specific (kh_last i) (kh_last j) (cons j m) (member j m) (1+ k))))                                      (and res                                           (cons k res))))))                        (and (kh_last i)                             (recurs_cumul (kh_last i) j                                           m b                                           (kh_cumul c (kh_inter_description (kh_node (kh_last i))))                                           (1+ k))))))                (recurs_equal_or_specific (i j m b k)                  (and (= (kh_address o) 0)                       (progn                         (print "recurs_equal_or_specific3")                         (not (kh_print i))                         (kh_print j)                         (print m)                         (print b)))                  (if (or (not (kh_to (kh_to (kh_relation i))))                          b)                    (list k)                    (or (and (kh_equal_or_specific (kh_note_description (kh_node i)) (kh_note_description j))                             (recurs_cumul i j m b (kh_inter_description (kh_node i)) k))))))         (let ((res (recurs_equal_or_specific o p nil nil 1)))           (and res                (reverse (cons 0 res)))))))(defmethod kh_all_specific ((o kh_occurrence))   (let ((res nil))     (labels ((recurs_all_specific (s)                (push s res)                (loop for r in (kh_specific s)                      when (not (member r res))                      do (recurs_all_specific r))))       (loop for s in (kh_specific o)             do (recurs_all_specific s)))     res))(defmethod kh_all_general ((o kh_occurrence))   (let ((res nil))     (labels ((recurs_all_general (s l)                ;(print "recurs_all_general")                ;(kh_print s)                ;(print l)                (push (list s l) res)                (loop for r in (kh_general s)                      when (not (member (car r) res :key #'car))                      do (recurs_all_general (car r) (kh_syntag_prod l (cadr r))))))       (loop for s in (kh_general (kh_node o))             do (recurs_all_general (car s) (kh_count (car s)))))     res))(defmethod kh_interonset ((occurrence kh_occurrence))  ; POUR QUOI FAIRE ?   (and (kh_last occurrence)        (- (kh_time (kh_param occurrence)) (kh_time (kh_param (kh_last occurrence))))))(defmethod kh_level ((occurrence kh_occurrence))   (if (kh_last occurrence)     (1+ (kh_level (kh_last occurrence)))     0))(defmethod kh_description ((occurrence kh_occurrence))   (kh_description (kh_node occurrence)))(defmethod kh_note_description ((o kh_occurrence))   (kh_note_description (kh_node o)))(defmethod kh_inter_description ((o kh_occurrence))   (kh_inter_description (kh_node o)))(defmethod kh_description ((relation kh_syntagmatic_relation))   ;(print "kh_description")   ;(print (kh_interpitch relation))   ;(print (kh_interdegree relation))   (make-instance 'kh_description     :kh_interpitch (and (kh_interpitch relation) (kh_sign_number (kh_interpitch relation)))     :kh_interdegree (and (kh_interdegree relation) (kh_sign_number (kh_interdegree relation)))     :kh_interonset (kh_interonset relation)     :kh_metric (kh_metric relation)     :kh_pitch (kh_pitch relation)))(defmethod kh_interpitch ((relation kh_syntagmatic_relation))   (and (kh_from relation)        (kh_pitch (kh_to relation)) (kh_pitch (kh_from relation))        (- (kh_pitch (kh_to relation)) (kh_pitch (kh_from relation)))))(defmethod kh_interdegree ((relation kh_syntagmatic_relation))   (and (kh_from relation)        (kh_degree (kh_to relation)) (kh_degree (kh_from relation))        (if (= (kh_degree (kh_to relation)) (kh_degree (kh_from relation)))          (and (= (kh_pitch (kh_to relation)) (kh_pitch (kh_from relation)))               0)          (- (kh_degree (kh_to relation)) (kh_degree (kh_from relation))))))(defmethod kh_interonset ((relation kh_syntagmatic_relation))   (and (kh_from relation)        (- (kh_time (kh_to relation)) (kh_time (kh_from relation)))))(defmethod kh_metric ((relation kh_syntagmatic_relation))   (kh_metric (kh_to relation)))(defmethod kh_pitch ((relation kh_syntagmatic_relation))   (kh_pitch (kh_to relation)))(defun kh_same_contour (contour interpitch)   (apply contour (list interpitch)))(defun kh_ascending (interpitch)   (> interpitch 0))(defun kh_descending (interpitch)   (< interpitch 0))(defun kh_constant (interpitch)   (= interpitch 0))(defmethod kh_contour ((relation kh_syntagmatic_relation))   (kh_contour (kh_interpitch relation)))(defmethod kh_contour ((n number))   (if (kh_ascending n)     #'kh_ascending     (if (kh_descending n)       #'kh_descending       #'kh_constant)))(defmethod kh_contour ((n t))   nil)(defmethod kh_sign ((f function))   f)(defmethod kh_number ((f function))   nil)(defmethod! kh_analyze ((midi list) &optional (contour t) (interonset t) (graph nil) (print nil) (channel 1) (ignore nil))   :initvals '(nil t t nil nil 1 nil)   :indoc '("a MIDI sequence (optionnally extended with pitch spelling informations)"            "should contour be taken into consideration ?"            "should interonset be taken into consideration ?"            "print either notes ('notes), all structures ('all) or nothing (nil) in the Listener")   :icon 128    :numouts 0   :doc  "Analyzes the MIDI sequence. (More precisely: the first MIDI channel.)inputs:midi: a MIDI sequenceinteronset: output: should interonset be taken into consideration ? (t or nil)no."   (setf *kh_note_counter* 0)   (setf *kh_node_counter* -1)   (setf *kh_cyclic_counter* 0)   (setf *kh_occurrence_counter* 0)   (setf *kh_interonset* interonset)   (setf *kh_contour* contour)   (setf *kh_meta* nil)   (setf *kh_print* print)   (setf *kh_specif* t)   (setf *kh_graph* graph)    (setf *kh_cycle* t)   (setf *kh_pitch* nil)   (setf *kh_transpos* t)   (setf *kh_root* (make-instance 'kh_pattern :kh_address (incf *kh_node_counter*)))   (setf *kh_note* (make-instance 'kh_pattern                     :kh_address (incf *kh_node_counter*)                     :kh_last *kh_root*                     :kh_description (make-instance 'kh_description)))   (push *kh_note* (kh_acyclic_children *kh_root*))   (push (list *kh_note* (list 0)) (kh_specific *kh_root*))   (push (list *kh_root* (list 0)) (kh_general *kh_note*))   (setf *kh_notes* nil)   (setf nodebug nil)   (loop for voice in (if (listp channel)                        channel                        (list channel))         with begin_time = (get-internal-real-time)          do (loop for event on (nth (1- voice) midi)                  do (progn (incf *kh_note_counter*)                            (if t;(< (second (car event)) 11700)                              (let ((note (make-instance 'kh_note                                            :kh_address *kh_note_counter*                                            :kh_time (second (car event))                                            :kh_metric (nth 6 (car event))                                            :kh_duration (and (cdr event)                                                              (- (second (cadr event)) (second (car event))))                                            :kh_chroma (first (car event))                                            :kh_degree (nth 5 (car event))                                            :kh_interdegree (and (cdr event)                                                                 (nth 5 (cadr event))                                                                 (nth 5 (car event))                                                                 (- (nth 5 (cadr event)) (nth 5 (car event))))                                                :kh_interpitch (and (cdr event)                                                                (first (cadr event))                                                                (first (car event))                                                                (- (first (cadr event)) (first (car event))))                                                :kh_duration (third (car event)))))                                (push note *kh_notes*)                                (and (equal *kh_print* 'all)                                     (progn                                       (terpri)                                       (terpri)                                       (format t "##########################################################################################################################################")))                                (and *kh_print*                                     (not (equal *kh_print* 'new))                                     (kh_print note))                                (and (equal *kh_print* 'all)                                     (progn                                       (terpri)                                       (format t "##########################################################################################################################################")))                                (or (member *kh_note_counter* ignore)                                    (kh_instantiate note))))))         finally do (let ((end_time (get-internal-real-time)))                      (terpri)                      (terpri)                      (format t "Elapsed time : ~D seconds." (* (/ (- end_time begin_time) internal-time-units-per-second) 1.0))                      (terpri)                      (format t "Pattern tree : ~D nodes, ~D cycles." *kh_node_counter* *kh_cyclic_counter*)                      (terpri)                      (format t "Occurrence trees : ~D nodes." *kh_occurrence_counter*)                      (terpri))))(defmethod! kh_analyze ((midifile MidiFile) &optional (contour t) (interonset t) (graph nil) (print nil) (channel 1) (ignore nil))   (kh_analyze (mf-info midifile) contour interonset graph print channel ignore))(defun kh_previous (event)   (if (or (not *kh_graph*)           (not (kh_anchor event)))     (and (cadr (member event *kh_notes*))          (list (cadr (member event *kh_notes*))))     (loop for m on (member event *kh_notes*)            with d = 0            with pitch_filter = t            with pitch_tab = (make-hash-table)            when (and ;(not (kh_print (cadr m)))                      pitch_filter                      (cadr m)                      ;(print 1)                      (or (equal (car m) event)                          (kh_anchor (cadr m)))                      ;(print 2)                      (or t (let* ((memo_dur (gethash (kh_pitch (cadr m)) pitch_tab))                                   (dur (- (kh_time (car m)) (kh_time (cadr m)))))                              (and (or (not memo_dur)                                       (> (/ dur memo_dur) 1.1))                                   (setf (gethash (kh_pitch (cadr m)) pitch_tab)                                         dur))))                      ;(print 3)                      (or (not (= (kh_pitch (cadr m))                                  (kh_pitch event)))                          (not (if nil ;(> (/ (kh_duration event) (kh_duration (cadr m))) 1.1)                                 nil                                 (setq pitch_filter nil))))                      ;(print 4)                      (or (equal (car m) event)                          (not (caddr m))                          (not (kh_interdegree (cadr m)))                          (not (kh_interdegree event))                          (= (kh_interdegree (cadr m)) 0)                          (= (kh_interdegree event) 0) ; Considérer les notes répétées                          (and (< (/ (kh_interdegree (caddr m)) (kh_interdegree (cadr m))) 0)                               (< (/ (kh_interdegree (cadr (member event *kh_notes*))) (kh_interdegree event) ) 0))                          (loop for pitch from (1+ (min (kh_pitch event) (kh_pitch (cadr m)))) to (1- (max (kh_pitch event) (kh_pitch (cadr m))))                                always (let ((duration (gethash pitch pitch_tab)))                                         (or (not duration)                                             (not (or ;(> (/ duration (kh_duration event)) 1.1)                                                   (> (/ duration (kh_duration (cadr m))) 1.1)))))))                      ;(print 5)                      (not (and (> (abs (- (kh_pitch (cadr m)) (kh_pitch event))) 1)                                 (loop for delta in '(-1 1)                                      thereis (let ((duration (gethash (+ (kh_pitch (cadr m)) delta) pitch_tab)))                                                (and duration                                                     (> (/ duration (kh_duration (cadr m))) 1.1))))))                      ;(print 6)                      (or t (not (and (= (kh_interdegree (cadr m)) ;; redondant avec le précédent ??                                         (if (> (kh_pitch (cadr m)) (kh_pitch event))                                           1                                           -1))                                      (> (/ (kh_duration (car m)) (kh_duration (cadr m)))                                         1.1))))                      ;(print 7)                      (or t                          (not (caddr m))                          (> (- (kh_time (cadr m)) (kh_time (caddr m)))                             d)                          (and (> (- (kh_time (car m)) (kh_time (cadr m)))                                  d)                               (setq d (- (kh_time (car m)) (kh_time (cadr m))))))                      ;(print 8)                      )            collect (progn                      ;(kh_print (cadr m))                      (cadr m)))))(defun kh_anchor (event)   ;(print "kh_anchor")   ;(kh_print event)   ;(print (kh_duration event))   (let ((memory (member event *kh_notes*)))     (or (not (cadr memory))         (and ;(> (kh_duration event) 150)          (not (and (< (abs (log (/ (kh_duration event) (kh_duration (cadr memory)))))                       0.1)                    (kh_interpitch event)                    (kh_interpitch (cadr memory))                    (= (kh_interpitch event)                       (kh_interpitch (cadr memory)))))))))(defmethod kh_instantiate ((event kh_object))   ;(print "kh_instantiate")   ;(kh_print event)   (and (or (typep event 'kh_note)            *kh_meta*)        (let ((relations (loop for old_event in (append (kh_previous event) (list nil))                               collect (let ((relation (make-instance 'kh_syntagmatic_relation :kh_from old_event :kh_to event)))                                         (and (kh_from relation)                                              (push relation (kh_from (kh_from relation))))                                         (push relation (kh_to (kh_to relation)))                                         relation))))          (loop for relation in relations                do (kh_run relation #'kh_memorize))          (loop for relation in relations                do (progn                     (setf *kh_new_occs* nil)                     ;(kh_run relation #'kh_memorize)                     ;(print 1)                     (kh_run relation #'kh_extend1)                     ;(print 2)                     (kh_run relation #'kh_extend2)                     ;(print 3)                     (loop for o in *kh_new_occs*                           do (kh_check_cyclic o))                     (kh_run relation #'kh_develop_test)                     ;(print 4)                     ;PAS BESOIN DE FAIRE PLUSIEURS kh_run !                     )))))(defun kh_extend1 (old_occurrence relation node)   (kh_extend old_occurrence relation node nil))(defun kh_extend2 (old_occurrence relation node)   (kh_extend old_occurrence relation node t))(defun kh_extend (old_occurrence relation node generalize)   ;(print "kh_extend")   ;(kh_print old_occurrence)   ;(and (print node) (kh_print node))   ;(print generalize)   ;(and (not generalize)   ;     (or (not old_occurrence)   ;         (not (cadr node)))   ;     (kh_memorize old_occurrence relation (car node)))   (kh_remember_test relation                     old_occurrence                     node                     generalize))(defun kh_memorize (old_occurrence relation node)   (and (equal (kh_address (car node)) -1)        (progn          (print "kh_memorize")          (kh_print old_occurrence)          (kh_print (kh_to relation))          (kh_print (car node))))   (and (kh_interpitch relation)        (push (list old_occurrence relation) (gethash (kh_interpitch relation) (kh_interpitch_associative_memory (car node)))))   (and (kh_interdegree relation)        (push (list old_occurrence relation) (gethash (kh_interdegree relation) (kh_interdegree_associative_memory (car node)))))   (or (member (kh_interpitch relation) (gethash (kh_contour relation) (kh_contour_associative_memory (car node))))       (push (kh_interpitch relation) (gethash (kh_contour relation) (kh_contour_associative_memory (car node)))))   ;(print (gethash (kh_interpitch relation) (kh_interpitch_associative_memory (car node))))   (and (kh_interonset relation)        (push (list old_occurrence relation) (gethash (kh_interonset relation) (kh_interonset_associative_memory (car node)))))   (and (kh_metric relation)        (push (list old_occurrence relation) (gethash (kh_metric relation) (kh_metric_associative_memory (car node)))))   (and (kh_pitch relation)        (push (list old_occurrence relation) (gethash (kh_pitch relation) (kh_pitch_associative_memory (car node))))))(defun kh_syntag_prod (l1 l2)   ;(print "kh_syntag_prod")   ;(print l1) ;the model   ;(print l2) ;the transformation (new generalization scheme)   ;(print   (if *kh_graph*     (let ((res (if l2                  (progn                    (and (>= (car l2) (length l1))                         ;(print ">>>>>>>")                         (setq l1 (append (loop for i from (- (car l2) (length l1)) downto 0                                                collect (1+ (+ i (car l1))))                                          l1)))                    (append (loop for i in (remove 0 l2)                                  with size = 0  ;(1- (- (length l1) (car l2)))                                  collect (nth (+ i size) (reverse l1)))                            #|with l1b = (print (first-n l1 (length l2)))                                collect (if (<= i (length l1b))                                          (print (nth i (reverse l1b)))                                          (progn                                            (print ">>>>>>>")                                            (print (+ (car l1b) (- i (length l1b)))))))|#                            (list 0)))                  l1)))       (and res            (if nil ;(last res 2)              (append (om- (butlast res) (1- (car (last res 2))))                      (list 0))              res)))     l1))   ;)(defun kh_generals (node)   (if nil     (progn       (print "kh_generals")       (kh_print node)))   (loop for g in (kh_general (car node))         when (or t                  (progn                    (print ">")                    (kh_print g)                    t))         collect (list (car g) (kh_syntag_prod (cadr node) (cadr g)))))(defun kh_run (relation function)   (let ((debug 0)         (remaining nil)         (list (and (kh_from relation) (kh_upto (kh_from relation))))         (new_element (kh_to relation)))     ;(prin1 'r)          (and (= (kh_address new_element) debug)          (progn            ;(setf *kh_print* 'all)            (print ">>>>>>>>>>>>>> kh_run")            (print function)            (loop for o in list                  do (kh_print o))            (print "---")            ))     (labels ((list_equal (l m)                (and (equal (car l) (car m))                     (equal (cadr l) (cadr m))))              (car_remaining (element)                (if (listp element)                  (car element)                  element))              (equal_remaining (x y)                (and (equal (car_remaining x) (car_remaining y))                     (equal (kh_node_remaining x) (kh_node_remaining y))))              (recurs_init (node element)                (and (= (kh_address new_element) debug)                     (print "recurs_init")                     (not (kh_print (car node)))                     (print (cadr node))                     (not (kh_print element))                     ;(print remaining)                     )                (or (member (car node) remaining :key #'cadr)                    (and (equal (car node) *kh_root*)                         (push (list nil (car node)) remaining))                    (not (kh_equal_or_specific element (car node)))                    (progn (and (= (kh_address new_element) debug)                                (print "."))                           (let ((specific (loop for o in list                                                 append (let ((spec (kh_equal_or_specific (kh_node o) (car node))))                                                          (and spec                                                               (progn (and (= (kh_address new_element) debug)                                                                           (progn (not (print ">>?"))                                                                                  (kh_print o)                                                                                  (print (kh_level o))                                                                                  t))                                                                      t)                                                               (list (list o spec))))))                                 (general_specific nil))                             (loop for s in specific                                   do (setq specific (remove (car s) specific :test #'kh_less_specific :key #'car)))                             (loop for s in specific                                   do (progn                                        (and (= (kh_address new_element) debug)                                             (progn (print ">>general_specific")                                                    (kh_print (car s))                                                    (print (cadr s))                                                    (kh_print node)                                                    ))                                        (push (list (car s) (car node) (kh_syntag_prod (cadr node) (cadr s))                                                    ;(cadr node)                                                    )                                              remaining))))                           (and (= (kh_address new_element) debug)                                (print ".."))                           (loop for general in (kh_generals node)                                 do (recurs_init general element))                           (and (= (kh_address new_element) debug)                                (print "..."))                           (and (typep (car node) 'kh_cyclic_pattern)                                (loop for general in (kh_general_cycle (car node))                                      do (recurs_init (list general (cadr node)) element)))                           ))                (and nil                     (= (kh_address new_element) debug)                     (progn                       (print ">>>>remaining :")                       (loop for r in remaining                             do (progn                                  (kh_print (car r))                                  (kh_print (cadr r))                                  (kh_print (caddr r))))                       (print "-----------")))                ;(print remaining)                )              (recurs_run (element)                (and (= (kh_address new_element) debug)                     ;(equal function #'kh_extend)                     (print "€€€€€€€€€€€€€€€€€€")                     (print "recurs_run?")                     (not (kh_print element))                     (not (kh_print (kh_from relation)))                     ;(not (kh_print (kh_node element)))                     ;(print "remaining :")                     ;(loop for r in remaining                     ;      do (progn                     ;           (kh_print (car r))                     ;           (kh_print (cadr r))                     ;           t))                     )                (if (typep element 'kh_pattern)                  (and (member element remaining :key #'cadr)                       (progn                         (and (= (kh_address new_element) debug)                              (setf *kh_print* 'all)                              (print "recurs_run")                              (kh_print element))                         ;(loop for specific in (kh_specific element)                         ;      do (and (print ">")                         ;              (not (kh_print specific))))                         ;(print 1)                         (loop for specific in (kh_specific element)                               when (and ;(print ">")                                     ;(not (kh_print specific))                                     (not (member (car specific) (kh_general element) :key #'car)))                               do (recurs_run (car specific)))                         (and (typep element 'kh_cyclic_pattern)                              (loop for specific in (kh_specific_cycle element)                                    do (recurs_run specific)))                         (and (= (kh_address new_element) debug)                              (progn (print 2)                                     (kh_print element)))                         (let ((res (car (member element remaining :key #'cadr)))                               (tag nil))                           (and res                                (progn                                  (if (and (car res)                                           (equal (kh_node (car res)) element))                                    (apply function (list (car res) relation (list element nil)))                                    (apply function (list (car res) relation (list element (caddr res)))))                                  ;(prin1 's)                                  )))                         (and (= (kh_address new_element) debug)                              (print 3))                         (setq remaining (remove element remaining :key #'cadr :test #'equal))                         ;(print "plus general")                                     ;(kh_print (car element))                                    (loop for general in (kh_general element)                               do (recurs_run (car general)))                         (and (typep element 'kh_cyclic_pattern)                              (loop for general in (kh_general_cycle element)                                    do (recurs_run element)))                         (and (= (kh_address new_element) debug)                              (print 4))                         ))                  (and (member (kh_node element) remaining :key #'cadr)                       (progn                         (and (= (kh_address new_element) debug)                              (setf *kh_print* 'all)                              (print "recurs_run")                              (not (kh_print element)))                         ;(kh_print (kh_node element)))                         ;(print 11)                         (loop for specific in (kh_specific element)                               when (not (member specific (kh_general element)))                               do (recurs_run specific))                         (and (= (kh_address new_element) debug)                              (print 22))                         ;(kh_print element)                         ;(print element)                         ;(print remaining)                         (and (member element remaining :key #'car_remaining)                              (progn                                (apply function (list element relation (list (kh_node element) nil)))                                ;(prin1 't)                                ))                         (and (= (kh_address new_element) debug)                              (print 33))                         (loop for general in (kh_general (kh_node element))                               when (or ;(not (print "?"))                                     ;(kh_print general);                                     (kh_equal_or_specific element (car general)))                               do (recurs_run (car general)))                         (and (= (kh_address new_element) debug)                              (print 44))                         )))))       (loop for element in list             do (recurs_init (list (kh_node element) (kh_count (kh_node element))) element))       (and (= (kh_address new_element) debug)            (progn              (print "remaining :")              (loop for r in remaining                    do (progn                         (kh_print (car r))                         (kh_print (cadr r))                         (kh_print (print (caddr r)))))              (print "-----------")))       (if list          (loop for element in list               do (progn                    ;(print "!!!!!!!!!!!!!!!!")                    (recurs_run element)))         (progn           (apply function (list nil relation (list *kh_root* nil)))           ;(prin1 'u)           ))       ;(print "fin")       )))(defun kh_most_specific_node (list)   ;(print "kh_most_specific_node")   (loop for occ in list         with most_specific = nil         do (progn              (and  (= (kh_address (kh_param (car (car list)))) (1- 0))                    (progn                      (print "kh_most_specific_node>>")                      (kh_print (car occ))                      (print most_specific)))              (setf most_specific (delete-if #'(lambda (x) (kh_equal_or_specific (kh_node occ) (kh_node x)))                                             most_specific))              (and (= (kh_address (kh_param (car (car list)))) (1- 0))                   (print most_specific))              (or (some #'(lambda (x) (kh_equal_or_specific (kh_node x) (kh_node occ)))                        most_specific)                  (push occ most_specific))              (and  (= (kh_address (kh_param (car (car list)))) (1- 0))                    (print most_specific))              )         finally return (progn                          (and nil                               (or ;(not list)                                (= (kh_address (kh_param (car (car list)))) (1- debug))                                (progn                                  (print ".......")                                  (loop for i in most_specific                                        do (kh_print i))                                  (print "................"))))                          most_specific)))(defun kh_most_specific (list)   ;(print "kh_most_specific")   ;(loop for i in list   ;      do (kh_print i))   ;(print "----------------")   (loop for occ2 in list         with most_specific = nil         do (let ((occ (if (listp occ2)                         (car occ2)                         occ2)))              (progn                ;(print ">>1")                ;(kh_print occ)                ;(print most_specific)                (setf most_specific (if (listp occ2)                                      (delete-if #'(lambda (x) (kh_equal_or_specific occ (car x)))                                                 most_specific)                                      (delete-if #'(lambda (x) (kh_equal_or_specific occ x))                                                 most_specific)))                ;(print most_specific)                (or (if (listp occ2)                      (some #'(lambda (x) (kh_equal_or_specific (car x) occ))                            most_specific)                      (some #'(lambda (x) (kh_equal_or_specific x occ))                            most_specific))                    (push occ2 most_specific))                ;(print most_specific)                ))         finally return (progn                          ;(loop for i in most_specific                          ;      do (kh_print i))                          ;(print "................")                          most_specific)))(defun kh_most_general (list)   ;(print "kh_most_general")   ;(loop for i in (print list)   ;      do (kh_print i))   ;(print "----------------")   (loop for occ2 in (reverse list)  ;parce dans kh_most_specific_node, si pattern apparait plusieurs fois, le meilleur syntag_prod semble etre au debut          with most_general = nil         do (let ((occ (if (listp occ2)                         (car occ2)                         occ2)))              (when (not (member occ2 most_general))                (progn                  ;(print ">")                  ;(kh_print occ)                  ;(print most_general)                  (setf most_general (if (listp occ2)                                       (delete-if #'(lambda (x) (kh_equal_or_specific x occ))                                                  most_general :key #'car)                                       (delete-if #'(lambda (x) (kh_equal_or_specific x occ))                                                  most_general)))                  (or (if (listp occ2)                        (some #'(lambda (x) (kh_equal_or_specific occ (car x)))                              most_general)                        (some #'(lambda (x) (kh_equal_or_specific occ x))                              most_general))                      (push occ2 most_general)))))         finally return (progn                          ;(loop for i in most_general                          ;      do (kh_print i))                          ;(print "................")                          most_general)))(defun kh_remember_test (relation occurrence node generalize)   ;(print "kh_remember_test")   ;(kh_print occurrence)   ;(kh_print node)   (db_print "kh_remember_test" 0 (kh_address (kh_to relation)))   (db_kh_print occurrence 0 (kh_address (kh_to relation)))   (db_kh_print (or (car node) (kh_node occurrence)) 0 (kh_address (kh_to relation)))   (setf debug (if generalize                 0                 0))   (if (= (kh_address (kh_to relation)) debug)     (progn       (setf *kh_print* 'all)       (print ">>>>>>kh_remember_test")       (kh_print occurrence)       (kh_print (kh_description relation))       (kh_print node)))   (let ((processed nil))     (labels ((recurs_child (c m children p)                (if (= (kh_address (kh_to relation)) debug)                  (progn                    (print "kh_recurs_child")                    (kh_print c)                    (kh_print m)))                (if (kh_equal (kh_description c) m)                  (and                   (if (equal (kh_last c) (car node))                     (progn                       (and (= (kh_address (kh_to relation)) debug)                            (print "4"))                       (kh_remember relation occurrence c node))                     (and (not (kh_nil (kh_description c) (car node)))                          (or (not (= (kh_address (kh_to relation)) debug))                              (print "3"))                          generalize                          (kh_remember_general relation occurrence (kh_description c) node c))))                  (and (kh_equal_or_specific (kh_description c) m)                       generalize                       (or (loop for g in (kh_general c)                                 thereis (and (or (not (= (kh_address (kh_to relation)) debug))                                                  (progn (print ">")                                                         (not (kh_print g))))                                          (member (car g) children)                                          (recurs_child (car g) m children p)))                           (and (= (kh_address (kh_to relation)) debug)                                (progn (print "1")                                       (kh_print c)))                           (kh_nil m (car node))                           (kh_remember_general relation occurrence m node c)))))              (recurs_parent (p)                (or (member p processed)                    (progn                      (push p processed)                      (if (= (kh_address (kh_to relation)) debug)                        (progn                          (print "recurs_parent")                          (kh_print p)                          (and (typep p 'kh_cyclic_pattern)                               (kh_print (kh_next p)))))                      ;(kh_print q)                      (let* ((children (if (typep p 'kh_cyclic_pattern)                                         (cons (kh_next p) (kh_children p))                                         (kh_children p)))                             (sorted (sort (copy-list children) #'kh_equal_or_specific)))                        (if (= (kh_address (kh_to relation)) debug)                          (progn (print (kh_cyclic_children p))                                 (print (kh_acyclic_children p))))                        (loop for child in sorted                              with list_match = (loop for c in sorted                                                      when (or (not (= (kh_address (kh_to relation)) debug))                                                               (not (print ">>>"))                                                               (kh_print (kh_to relation))                                                               (kh_print c)                                                               (kh_print (kh_match (kh_description relation) (kh_description c)))                                                               t)                                                      collect (kh_match (kh_description relation) (kh_description c)))                              for match in list_match                              for remaining_match on list_match                              do (progn                                   (if (= (kh_address (kh_to relation)) debug)                                     (progn                                       (print "child")                                       (kh_print child)                                       (kh_print match)                                       (kh_print (kh_description relation))                                       ))                                   (if (kh_equal_or_specific (kh_description relation) (kh_description child))                                     (if (equal p (car node))                                       (progn                                         ;(print "1.5")                                         (kh_remember relation occurrence child node))                                       (and generalize                                            (progn                                              ;(print "2")                                              ;(kh_print p)                                              (kh_remember_general relation occurrence (kh_description child) node child))))                                     (recurs_child child match sorted p))))                        (loop for s in (kh_specific p)                              when (and ;(print ">")                                    ;(not (kh_print p))                                    ;(not (kh_print s))                                    (not (equal p (car s)))                                    (or (not (kh_from relation))                                        (not (member (car s) (kh_upto (kh_from relation)) :key #'kh_node :test #'kh_equal_or_less_specific))))                              do (recurs_parent (car s))))))                (if (= (kh_address (kh_to relation)) debug)                  (progn                    (print "ok_recurs_parent")                    (kh_print p)))                ))       (recurs_parent (car node))))   (if (= (kh_address (kh_to relation)) debug)     (print "done"))   )(defun kh_remember (relation occurrence n node)   (db_print "kh_remember" 0 (kh_address (kh_to relation)))   (if (= (kh_address (kh_to relation)) 0)     (progn       (print "kh_remember?")       (kh_print (kh_to relation))       (kh_print occurrence)       (kh_print node)       (kh_print n)       ))   ;(and node (kh_print (car node)))   ;(kh_print occurrence)   ;(kh_print n)   (let ((new_element (kh_to relation))         (specifocc (kh_generalize occurrence node)))     (or (kh_subsumed_extension specifocc (kh_to relation) (kh_description n))         (loop for oc in (kh_upto new_element)               thereis (and (or (not occurrence)                                (progn                                  (if (= (kh_address (kh_to relation)) 0)                                    (progn                                      (print ">")                                      (kh_print oc)                                      (kh_print (kh_last oc))                                      (kh_print specifocc)                                      ))                                  (and specifocc                                       (kh_last oc)                                       (equal (kh_param specifocc) (kh_param (kh_last oc)))                                       (kh_equal_or_specific (kh_last oc) specifocc))))                            (kh_equal_or_specific (kh_description oc) (kh_description n))))         (let ((newocc (and (or (equal (car node) *kh_root*)                                specifocc)                            (progn                              (if (= (kh_address (kh_to relation)) 0)                                (progn                                  (print "kh_remember!")                                  (kh_print occurrence)                                  (kh_print (car node))                                  (kh_print specifocc)                                  (kh_print n)                                  ;(print (kh_children (car node)))                                  ))                              (kh_instantiate_node specifocc relation n t nil)))))           (and newocc                (progn (kh_interlink newocc)                       ;(kh_check_cyclic newocc)                       (push newocc *kh_new_occs*)                       ))           ;(kh_print n)           newocc))))(defun kh_filter (description)   (make-instance 'kh_description     :kh_interpitch (and (kh_interpitch description)                         (or *kh_contour*                             (kh_number (kh_interpitch description)))                         (kh_sign (kh_interpitch description))                         (kh_interpitch description))     :kh_interdegree (and (kh_interdegree description)                          (kh_number (kh_interdegree description))                          (kh_sign (kh_interdegree description))                          (kh_interdegree description))     :kh_interonset (kh_interonset description)     :kh_metric (kh_metric description)     :kh_pitch (kh_pitch description)))(defun kh_filter3 (description old_spec old_act spec)   ;(print "kh_filter3")   ;(kh_print description)   ;(kh_print old_spec)   ;(kh_print old_act)   ;(kh_print spec)   (let* ((res (make-instance 'kh_description                 :kh_interpitch (and (or (not (kh_equal (kh_interpitch old_spec) (kh_interpitch spec)))     ;les dimensions suivant lesquelles le motif spécifique s'étend uniformément,                                         (kh_equal (kh_interpitch old_spec) (kh_interpitch old_act))            ;alors que l'occurrence différait du spécifique,                                         (not (kh_equal (kh_interpitch description) (kh_interpitch spec)))) ;ne doivent pas être étendues uniformément.                                     (kh_interpitch description))                 :kh_interdegree (and (not (and (kh_equal (kh_interdegree old_spec) (kh_interdegree spec))                                                (not (kh_equal (kh_interdegree old_spec) (kh_interdegree old_act)))                                                (kh_equal (kh_interdegree description) (kh_interdegree spec))))                                      (kh_interdegree description))                 :kh_interonset (and (not (and (kh_equal (kh_interonset old_spec) (kh_interonset spec))                                               (not (kh_equal (kh_interonset old_spec) (kh_interonset old_act)))                                               (kh_equal (kh_interonset description) (kh_interonset spec))))                                     (kh_interonset description))                 :kh_metric (and (not (and (kh_equal (kh_metric old_spec) (kh_metric spec))                                           (not (kh_equal (kh_metric old_spec) (kh_metric old_act)))                                           (kh_equal (kh_metric description) (kh_metric spec))))                                 (kh_metric description))                 :kh_pitch (and (not (and (kh_equal (kh_pitch old_spec) (kh_pitch spec))                                          (not (kh_equal (kh_pitch old_spec) (kh_pitch old_act)))                                          (kh_equal (kh_pitch description) (kh_pitch spec))))                                (kh_pitch description)))))     ;(kh_print res)     res))(defmethod kh_continuous ((occurrence kh_occurrence) (description kh_description))   (and (equal (kh_address (car *kh_notes*)) 0)        (progn (print "kh_continuous")               (kh_print occurrence)))   (or (equal (kh_last (kh_node occurrence)) *kh_root*)       (let* ((continuous (make-instance 'kh_description                            :kh_interpitch (and (kh_interpitch (kh_description occurrence))                                                (kh_interpitch description))                            :kh_interdegree (and (kh_interdegree (kh_description occurrence))                                                 (kh_interdegree description))                            :kh_interonset (and (kh_interonset (kh_description occurrence))                                                (kh_interonset description))                            :kh_metric (and (kh_metric (kh_description occurrence))                                            (kh_metric description))                            :kh_pitch (and (kh_pitch (kh_description occurrence))                                           (kh_pitch description)))))         (and (equal (kh_address (car *kh_notes*)) 0)              (kh_print continuous))         (not (or (kh_nil continuous nil)                  (kh_check_emergence occurrence continuous))))))(defmethod kh_continuous ((node kh_pattern) (description kh_description))   ;(print "kh_continuous")   ;(kh_print description)   ;(kh_print node)   (or (equal (kh_last node) *kh_root*)       (let* ((continuous (make-instance 'kh_description                            :kh_interpitch (and (kh_interpitch (kh_description node))                                                (kh_interpitch description))                            :kh_interdegree (and (kh_interdegree (kh_description node))                                                 (kh_interdegree description))                            :kh_interonset (and (kh_interonset (kh_description node))                                                (kh_interonset description))                            :kh_metric (and (kh_metric (kh_description node))                                            (kh_metric description))                            :kh_pitch (and (kh_pitch (kh_description node))                                           (kh_pitch description)))))         (not (kh_nil continuous nil)))))(defun kh_remember_general (relation occurrence description node specific_child)   (setq debug 0)   (db_print "kh_remember_general1" 0 (kh_address (kh_to relation)))   (db_kh_print (car node) 0 (kh_address (kh_to relation)))   (and (= (kh_address (kh_to relation)) debug)        (progn          (print "kh_remember_general?")          (kh_print occurrence)          (kh_print specific_child)          (kh_print description)          (kh_print (car node))))   (let ((new_element (kh_to relation)))     (setq description (kh_filter description))     (or      (and occurrence           (progn (and (= (kh_address new_element) 0)                       (progn                         (print "kh_filter3??")                         (kh_print description)                                (kh_print (kh_last specific_child))                         (kh_print (kh_description relation))                         (kh_print specific_child)))                  (setq description (kh_filter3 description                                                (kh_description (kh_last specific_child))                                                (kh_description relation)                                                (kh_description specific_child)))                  (and (= (kh_address new_element) 0)                       (progn                         (print "kh_filter3::")                         (kh_print description)                                (kh_print (car node))))                  (kh_nil description (car node))))      ;(not (print "kh_remember_general??????"))      (let ((oldocc (kh_generalize occurrence node)))        (and (= (kh_address new_element) debug)             (progn               (print ">>")               (kh_print occurrence)               (kh_print node)               (kh_print oldocc)               (kh_print description)))        (or (if occurrence              (kh_subsumed_extension oldocc new_element description)              (loop for oc in (kh_upto new_element)                    thereis (kh_equal_or_specific (kh_description (kh_node oc)) description)))            (and (= (kh_address new_element) debug)                 (progn                   (setf *kh_print* 'all)                   (print "kh_remember_general!!!")                   (kh_print (car node))                   (kh_print specific_child)                   (kh_print occurrence)                   (kh_print (kh_generalize occurrence node))                   (kh_print description)                   (and nil                        (typep (car node) 'kh_cyclic_pattern)                        (kh_print (kh_description (kh_next (car node)))))                   nil))            (and occurrence                 (or (not oldocc)                     ;(not (print 1))                     (not (kh_continuous oldocc description))))            (let ((node_created t))              ;(print "ici")              (or (and (typep (car node) 'kh_cyclic_pattern)                       (kh_equal_or_specific (kh_description (kh_next (car node))) description)                       (kh_generalize_cycle description oldocc relation))                  (or (if (not (typep (car node) 'kh_cyclic_pattern))                        (let ((cyclic_child (loop for c in (kh_children (car node))                                                  when (typep c 'kh_cyclic_pattern)                                                  return c)))                          (if cyclic_child                            (progn                              (and (= (kh_address new_element) debug)                                   (progn                                     (print ">>cc")                                     (kh_print cyclic_child)))                              (let ((cyclic_occ (loop for o in (kh_upto (kh_param occurrence))                                                      when (kh_equal_or_specific o (kh_last cyclic_child))                                                      return o)))                                (or (and cyclic_occ                                         (kh_new_cycle cyclic_occ                                                       description                                                       (list (kh_last cyclic_child) (cadr node))                                                       relation))                                    (and (kh_equal_or_specific (kh_description cyclic_child) description)                                         (let* ((check (member description (kh_general_cycles cyclic_child) :key #'kh_description :test #'kh_equal))                                                (new nil)                                                (general_cycle (or (and check                                                                        (not (setq node_created nil))                                                                        (car check))                                                                   (not (setq new 'generalize))                                                                   (kh_change_cycle description (kh_last cyclic_child) 'generalize (kh_new occurrence)))))                                           (kh_instantiate_node occurrence relation general_cycle t new))))))                            (kh_new_cycle oldocc description node relation)))                        (kh_new_cycle oldocc description node relation))                      (let ((res (kh_new_phase oldocc specific_child relation description)))                        (and res                             (or (= res 1)                                 (not (setq node_created nil)))))                      (and (= (kh_address new_element) debug)                           (progn                             (print ">>>>>>>>>>> cyclic specific child")                             (kh_print (car node))                             (kh_print specific_child)                             (kh_print new_element)                             (kh_print occurrence)                             (kh_print description)))                      (let* ((newnode (make-instance 'kh_pattern                                        :kh_address (incf *kh_node_counter*)                                        :kh_last (car node)                                        :kh_description description))                             (newocc (kh_instantiate_node oldocc relation newnode t nil)))                        (or (member newnode (kh_acyclic_children (car node)))                            (push newnode (kh_acyclic_children (car node))))                        (kh_interlink newocc)                        (if nil                          (progn                            (print "kh_remember_general")                            (kh_print newnode)))                        ;(kh_print (car node))                        ;(kh_print description)                        ;(print 'a)                        (kh_interlink_node newnode (car node) description t)                        ;(print "here")                        ;(kh_check_cyclic newocc)                        (push newocc *kh_new_occs*)                        ;(print "there")                        ;(kh_print (car node))                        ;(loop for child in (kh_children (car node))                        ;      do (kh_print child))                        ;(print "..")                        (and (equal *kh_print* 'all)                             (kh_print newnode)))))              (and node_created                   (kh_generalize_general specific_child description (car node))))            t)))))(defun kh_subsumed_extension (old_occ new_element description)   ;(print "kh_subsumed_extension")   ;(kh_print old_occ)   ;(kh_print new_element)   ;(kh_print description)   (and old_occ        (loop for oc in (kh_upto (kh_param old_occ))              thereis (and (or (not (= (kh_address new_element) 0))                               (progn                                 ;(print ">>")                                 ;(not (kh_print oc))                                 ;(not (kh_print (kh_node oc)))                                 ;(not (kh_print (car node)))                                 ))                           (or (not (kh_last old_occ))                               (kh_equal_or_specific oc old_occ))                           (labels ((find_next (o d)                                      (or (not (= (kh_address new_element) 0))                                          (progn                                            ;(print "find_next")                                            ;(not (kh_print o))                                            ;(not (kh_print d))                                            ))                                      (loop for next in (kh_next o)                                            thereis (let ((newd (kh_cumul d (kh_description next))))                                                      (or (and (kh_equal_or_specific newd description)                                                               (progn ;(print "kh_subsumed_extension!")                                                                      ;(kh_print old_occ)                                                                      ;(kh_print new_element)                                                                      ;(kh_print description)                                                                      ;(kh_print o)                                                                      ;(kh_print newd)                                                                      t))                                                          (and (< (kh_address (kh_param next)) (kh_address new_element))                                                               (find_next next newd)))))))                             (find_next oc nil))))))(defun kh_generalize_general (node description context)   ;(print "kh_generalize_general?")   ;(kh_print node)   ;(kh_print description)   ;(kh_print context)   (labels ((recurs_collect_general (n l)              (and (not (member n l :test #'kh_equal))                   (kh_remove_duplicate (cons n (loop for s in (kh_general n)                                                      append (recurs_collect_general (car s) (cons n l))))))))     (loop for g in (recurs_collect_general (kh_last node) nil)           with next = nil           when (and ;(print ">")                 ;(not (kh_print g))                 ;(not (kh_print node))                 ;(not (kh_print (kh_last node)))                 (not (equal g context))                 (kh_equal_or_specific context g)                 (setq next (loop for n in (if (typep g 'kh_cyclic_pattern)                                             (cons (kh_next g) (kh_children g))                                             (kh_children g))                                  when (kh_equal_or_specific (kh_description n) description)                                  return n))                 ;(or (not (typep g 'kh_cyclic_pattern))                 ;    (progn (kh_print (kh_next g))                 ;           (print "..")))                 (not (equal next node))                 (not (member description                               (if (typep g 'kh_cyclic_pattern)                                (cons (kh_next g) (kh_children g))                                (kh_children g))                              :key #'kh_description :test #'kh_equal))                 ;(print 2)                 (kh_continuous g description))           do (progn                (and (= (kh_address (car *kh_notes*)) 0)                     (progn                       (print "kh_generalize_general")                       (kh_print next)                       (kh_print node)                       (kh_print description)                       (kh_print g)                       (kh_print context)))                (if (typep next 'kh_cyclic_pattern)                  (or (loop for d in (kh_collect_general_cycle next)                            thereis (and ;(print ">>")                                     ;(not (kh_print d))                                     (kh_equal (kh_description d) description)                                     (or (equal (kh_last d) d)                                         (kh_equal_period (kh_last d) (kh_last next)))))                      (kh_generalize_general_cycle node next description context))                  (let ((newnode (make-instance 'kh_pattern                                   :kh_address (incf *kh_node_counter*)                                   :kh_last g                                   :kh_description description)))                    (if nodebug                      (progn                        (print "kh_generalize_general")                        (kh_print newnode)))                    (or (member newnode (kh_acyclic_children g))                        (push newnode (kh_acyclic_children g)))                    ;(print 'kh_generalize_general)                    (kh_interlink_node newnode g description t)                    (and (equal *kh_print* 'all)                         (kh_print newnode))                    newnode))))));;;;;; PATTERN DISCOVERY;;;(defun kh_new_most_specific (occurrence)   (and (equal (kh_address (car *kh_notes*)) 0)        (print "kh_new_most_specific")        (kh_print occurrence))   (kh_most_general (loop for occ in (kh_upto (kh_param occurrence))                          when (and (or (not (equal (kh_address (car *kh_notes*)) 0))                                        (not (print "?"))                                        (not (kh_print occ)))                                    (kh_equal_or_specific occ occurrence)                                    (not (equal occ occurrence)))                          collect (progn                                    (and (equal (kh_address (car *kh_notes*)) 0)                                         (print ">")                                         (kh_print occ))                                    occ))))(defun kh_new_most_specific_node (node description newnode)   (setq debug 0)   (and (= (kh_address newnode) debug)        (print "kh_new_most_specific_node")        (not (kh_print node))        ;(not (kh_print description))        (kh_print newnode))   (kh_most_general (loop for occ in (let ((list_specific nil))                                       (labels ((recurs_new_most_specific_node (o l)                                                  (and (= (kh_address newnode) debug)                                                       (print "recurs_new_most_specific_node")                                                       (not (kh_print o))                                                       (print l))                                                  (and (not (member o list_specific :key #'car))                                                       (push (list o l) list_specific))                                                  (loop for s in (kh_specific o)                                                        when (not (member o (kh_specific (car s)) :key #'car))                                                        do (recurs_new_most_specific_node (car s) (kh_syntag_prod (cadr s) l)))))                                         (recurs_new_most_specific_node node (kh_count node))                                         list_specific))                          when (or (not (= (kh_address newnode) debug))                                   (not (print ">occ>"))                                   (not (kh_print occ))                                   t)                          append (labels ((recurs_new_specific (o d i l n s)                                            (and (= (kh_address newnode) debug)                                                 (progn                                                   (print "recurs_new_specific")                                                   (kh_print o)                                                   (print i)                                                   (print l)                                                   (print n)                                                   (print s)))                                            (and (not (member o l))                                                 (loop for next in (if (and (typep o 'kh_cyclic_pattern)                                                                            (kh_next o)                                                                            (kh_equal_or_specific (kh_last (kh_next o)) node))                                                                     (cons (kh_next o) (kh_children o))                                                                     (kh_children o))                                                       append (progn (and nil                                                                          (kh_cyclicp o)                                                                          (progn                                                                            (setq n (remove -1 (mapcar #'1- n)))                                                                            (setq s (or s i))))                                                                     (append (and (not (equal next newnode))                                                                                  (or (not (= (kh_address newnode) debug))                                                                                      (progn (print ">next>")                                                                                             (not (kh_print next))                                                                                             ;(print (kh_interpitch (kh_description next)))                                                                                             ;(print (kh_interpitch description))                                                                                             t))                                                                                  ;(print 1)                                                                                  (kh_equal_or_specific next newnode)                                                                                  ;(print 2)                                                                                  (kh_equal_or_specific (kh_note_description next) (kh_note_description description))                                                                                  (kh_equal_or_specific (if d                                                                                                          (kh_cumul d (kh_inter_description next))                                                                                                          (kh_inter_description next))                                                                                                        (kh_inter_description description))                                                                                  ;(print 3)                                                                                  (not (and (equal o node)                                                                                            (kh_equal description (kh_description next))))                                                                                  ;(print 4)                                                                                  (progn                                                                                    (or (not (= (kh_address newnode) debug))                                                                                        (not (print ">>>>next>"))                                                                                        (kh_print next))                                                                                    ;(kh_print (car occ))                                                                                    ;(kh_print description)                                                                                    ;(kh_print (kh_description next))                                                                                    (list (list next                                                                                                 (if (kh_cyclicp next)                                                                                                  (cons (or s i) (remove -1 (mapcar #'1- n)))                                                                                                  (cons (or s (1+ i)) n))))))                                                                                                                                                          (and *kh_graph*                                                                                  (recurs_new_specific next                                                                                                       (if d                                                                                                         (kh_cumul d (kh_inter_description next))                                                                                                         (kh_inter_description next))                                                                                                       (1+ i)                                                                                                       (cons o l)                                                                                                       n                                                                                                       s))))))))                                   (recurs_new_specific (car occ) nil (caadr occ) nil (cadr occ) nil)))))(defun kh_new_most_general (occurrence)   ;(print "kh_new_most_general")   ;(kh_print occurrence)   (kh_most_specific (loop for occ in (kh_upto (kh_param occurrence))                           when (and (kh_equal_or_specific occurrence occ)                                     (not (equal occ occurrence)))                           collect (progn                                     ;(print ">")                                     ;(kh_print occ)                                     occ))))(defun kh_new_most_general_node (node description newnode) ;;ATTENTION COMMENT FAIRE POUR DECOUVRIR UN CYCLE DE PLUSIEURS ETATS COMME NOUVEAU PLUS GENERAL, S'IL;; N'ETAIT PAS PLUS GENERAL DANS LE PREFIXE ??   (let ((debug 0))     (and (= (kh_address newnode) debug)          (progn            (print "kh_new_most_general_node")            ;(kh_print node)            ;(kh_print description)            (kh_print newnode)))     (or (let* ((memo_general nil)                (list_general nil)                (res (kh_most_specific (labels ((recurs_new_most_general_node (o li)                                                  (and (not (member o memo_general))                                                       (push (list o li) list_general)                                                       (push o memo_general))                                                  (and (= (kh_address newnode) debug)                                                       (progn                                                         (print "recurs_new_most_general_node")                                                         (kh_print o)                                                         (print li)))                                                  (loop for s in (kh_general o)                                                        when (progn                                                               ;(print ">>")                                                               ;(kh_print s)                                                               (not (member o (kh_general (car s)) :key #'car)))                                                        do (recurs_new_most_general_node (car s) (cadr s))))                                                (recurs_new_general (no d l n i)                                                  (and (= (kh_address newnode) debug)                                                       (progn                                                         (print "recurs_new_general")                                                         (kh_print no)                                                         (kh_print d)                                                         (print l)                                                         (print n)                                                         (print i)))                                                  (and no                                                       (not (member no l))                                                       (append (loop for occ in (progn                                                                                  (setq list_general nil)                                                                                  (recurs_new_most_general_node no (kh_count no))                                                                                  ;(print "...")                                                                                  list_general)                                                                     when (and (or (not (= (kh_address newnode) debug))                                                                                   (progn                                                                                     (print ">occ>")                                                                                     (not (kh_print occ))                                                                                     t))                                                                               (not (kh_cyclicp (car occ))))                                                                     append (loop for next in (if (and (typep (car occ) 'kh_cyclic_pattern)                                                                                                       (kh_next (car occ)))                                                                                                (cons (kh_next (car occ)) (kh_children (car occ)))                                                                                                (kh_children (car occ)))                                                                                  with newn = (kh_syntag_prod (cons i n)                                                                                                              (cons (1+ (caadr occ)) (cadr occ)))                                                                                  append (and (not (equal newnode next))                                                                                              (progn                                                                                                (and (= (kh_address newnode) debug)                                                                                                     (progn                                                                                                       (print ">next>")                                                                                                       (kh_print (car occ))                                                                                                       (kh_print next)                                                                                                       (print (kh_equal_or_specific description (kh_description next)))                                                                                                       (print (not (and (equal occ node)                                                                                                                        (kh_equal description (kh_description next)))))))                                                                                                (and ;(print 1)                                                                                                 (kh_equal_or_specific (kh_note_description description) (kh_note_description next))                                                                                                 (kh_equal_or_specific (kh_inter_description description)                                                                                                                       (if d                                                                                                                         (kh_cumul d (kh_inter_description next))                                                                                                                         (kh_inter_description next)))                                                                                                 ;(print 2)                                                                                                 (kh_equal_or_specific newnode next)                                                                                                 ;(print 3)                                                                                                 (not (and (equal (car occ) node)                                                                                                           (kh_equal description (kh_description next))))                                                                                                 ;(print 4)                                                                                                 (progn (and (= (kh_address newnode) debug)                                                                                                             (not (kh_print next))                                                                                                             (print (list next newn)))                                                                                                        (list (list next newn))))))))                                                               (and *kh_graph*                                                                    (recurs_new_general (kh_last no)                                                                                        (if d                                                                                          (kh_cumul d (kh_inter_description no))                                                                                          (kh_inter_description no))                                                                                        (cons no l)                                                                                        (cdr n)                                                                                        i))))))                                         (recurs_new_general node nil nil                                                             (if nil ;(kh_cyclicp newnode)                                                               (remove -1 (mapcar #'1- (kh_count node)))                                                               (kh_count node))                                                             (if nil ;(kh_cyclicp newnode)                                                               (car (kh_count node))                                                               (1+ (car (kh_count node)))))))))           (and (= (kh_address newnode) debug)                (print "final")                (kh_print res))           res)         (list (list *kh_root* (list 0))))))(defun kh_recall (param memory node)   (let ((condibug (and ;nil                    (= (kh_address (car *kh_notes*)) 0)                    (equal param 0)                    (not (kh_cyclicp (car node)))                    (equal (kh_address (car node)) 3))))     (if condibug       (progn           (print "kh_recall")         (print param)         (print memory)         (kh_print node)))     (let ((processed nil)           (recalled nil))       (labels ((recurs_recall (n)                  (and (not (member n processed))                       (push n processed)                       (progn                          (if condibug                           (progn                               (print "recurs_recall?")                             (kh_print n)                             (print (gethash param (apply memory (list n))))))                         ;(print 1)                         (loop for m in (gethash param (apply memory (list n)))                               do (progn                                    (and condibug                                         (progn                                             (print ">")                                           (kh_print n)                                           (kh_print (car m))                                           (kh_print (kh_to (cadr m)))                                           t))                                    (let ((members (if (listp m)                                                     (member (cadr m) recalled :key #'cadr)                                                     (member m recalled))))                                      (or members                                          (progn                                            (and nil ;condibug                                                 (progn                                                     (print ">")                                                   (kh_print n)                                                   (kh_print (car m))                                                   (kh_print (kh_to (cadr m)))                                                   t))                                            (push (if (typep m 'list)                                                    (append m (list n))                                                    m)                                                  recalled))))))                         (if condibug                           (print 2))                         (loop for s in (kh_specific n)                               do (recurs_recall (car s)))                         ;(print 3)                         (and (typep n 'kh_cyclic_pattern)                              (loop for s in (kh_specific_cycle n)                                    do (recurs_recall s)))                         (if condibug                           (progn                               (print "recurs_recall")                             (kh_print n)                             (print (gethash param (apply (print memory) (list n))))))                         ))))         (recurs_recall (car node))         (and condibug              (print "###")              ;(listp (car recalled))              (not (loop for r in recalled                         when (listp r)                         do (progn                              (kh_print (car r))                              (kh_print (kh_to (cadr r))))))              (print "..."))         recalled))))(defun kh_develop_test (occurrence relation node)   (db_print "kh_develop_test" 0 (kh_address (kh_to relation)))   (db_kh_print occurrence 0 (kh_address (kh_to relation)))   (db_kh_print node 0 (kh_address (kh_to relation)))   (and ;(= (kh_address (car *kh_notes*)) 0)    ;(setf *kh_print* 'all)    ;(print "*******************")            ;(print "kh_develop_test")    ;(not (kh_print occurrence))    ;(kh_print (car node))    ;(kh_print (kh_description relation))    )   (let* ((interpitch (kh_interpitch relation))          (interdegree (kh_interdegree relation))          (contour (kh_contour relation))          (signed_interpitch (make-instance 'kh_signed_number :kh_sign contour :kh_number (and interpitch (abs interpitch))))          (signed_interdegree (make-instance 'kh_signed_number :kh_sign contour :kh_number (and interdegree (abs interdegree))))          ;(unsigned_interpitch (make-instance 'kh_signed_number :kh_sign nil :kh_number (and interpitch (abs interpitch))))          ;(unsigned_interdegree (make-instance 'kh_signed_number :kh_sign nil :kh_number (and interdegree (abs interdegree))))          (sign_interpitch (make-instance 'kh_signed_number :kh_sign contour :kh_number nil))          (interonset (and *kh_interonset* (kh_interonset relation)))          (metric (kh_metric relation))          (pitch (kh_pitch relation))          (interpitch_hash (kh_recall interpitch #'kh_interpitch_associative_memory node))          ;(abs_interpitch_hash (and interpitch          ;                          (if (= interpitch 0)          ;                            interpitch_hash          ;                            (append interpitch_hash (kh_recall (- interpitch) #'kh_interpitch_associative_memory node)))))          (interdegree_hash (kh_recall interdegree #'kh_interdegree_associative_memory node))          ;(abs_interdegree_hash (and interdegree          ;                           (if (= interdegree 0)          ;                             interdegree_hash          ;                             (append interdegree_hash (kh_recall (- interdegree) #'kh_interdegree_associative_memory node)))))          (contour_hash (and (not (equal contour #'kh_constant))                             (loop for interpitches in (kh_recall contour #'kh_contour_associative_memory node)                                   append (kh_recall interpitches #'kh_interpitch_associative_memory node))))          (interonset_hash (kh_recall interonset #'kh_interonset_associative_memory node))          (metric_hash (kh_recall metric #'kh_metric_associative_memory node))          (pitch_hash (kh_recall pitch #'kh_pitch_associative_memory node)))     (and pitch          *kh_pitch*          (progn (and interonset                      metric                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_interpitch signed_interpitch :kh_interdegree signed_interdegree :kh_pitch pitch :kh_metric metric :kh_interonset interonset)                                           (kh_intersect interpitch_hash (kh_intersect interdegree_hash (kh_intersect pitch_hash (kh_intersect interonset_hash metric_hash))))                                           relation                                           node))                 (and interonset                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_interpitch signed_interpitch :kh_interdegree signed_interdegree :kh_pitch pitch :kh_interonset interonset)                                           (kh_intersect interpitch_hash (kh_intersect interdegree_hash (kh_intersect pitch_hash interonset_hash)))                                           relation                                           node))                 (and metric                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_interpitch signed_interpitch :kh_interdegree signed_interdegree :kh_pitch pitch :kh_metric metric)                                           (kh_intersect interpitch_hash (kh_intersect interdegree_hash (kh_intersect pitch_hash metric_hash)))                                           relation                                           node))                 ;(kh_associative_test occurrence                 ;                     (make-instance 'kh_description :kh_interpitch unsigned_interpitch :kh_interdegree unsigned_interdegree :kh_pitch pitch :kh_interonset interonset)                 ;                     (kh_intersect abs_interpitch_hash (kh_intersect abs_interdegree_hash (kh_intersect pitch_hash interonset_hash)))                 ;                     relation                 ;                     node)                 (and interonset                      metric                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_interdegree signed_interdegree :kh_pitch pitch :kh_metric metric :kh_interonset interonset)                                           (kh_intersect interdegree_hash (kh_intersect pitch_hash (kh_intersect interonset_hash metric_hash)))                                           relation                                           node))                 (and interonset                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_interdegree signed_interdegree :kh_pitch pitch :kh_interonset interonset)                                           (kh_intersect interdegree_hash (kh_intersect pitch_hash interonset_hash))                                           relation                                           node))                 (and metric                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_interdegree signed_interdegree :kh_pitch pitch :kh_metric metric)                                           (kh_intersect interdegree_hash (kh_intersect pitch_hash metric_hash))                                           relation                                           node))                 ;(kh_associative_test occurrence                 ;                     (make-instance 'kh_description :kh_interdegree unsigned_interdegree :kh_pitch pitch :kh_interonset interonset)                 ;                     (kh_intersect abs_interdegree_hash (kh_intersect pitch_hash interonset_hash))                 ;                     relation                 ;                     node)                 (and interonset                      metric                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_interpitch signed_interpitch :kh_pitch pitch :kh_metric metric :kh_interonset interonset)                                           (kh_intersect interpitch_hash (kh_intersect pitch_hash (kh_intersect interonset_hash metric_hash)))                                           relation                                           node))                 (and interonset                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_interpitch signed_interpitch :kh_pitch pitch :kh_interonset interonset)                                           (kh_intersect interpitch_hash (kh_intersect pitch_hash interonset_hash))                                           relation                                           node))                 (and metric                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_interpitch signed_interpitch :kh_pitch pitch :kh_metric metric)                                           (kh_intersect interpitch_hash (kh_intersect pitch_hash metric_hash))                                           relation                                           node))                 ;(kh_associative_test occurrence                 ;                     (make-instance 'kh_description :kh_interpitch unsigned_interpitch :kh_pitch pitch :kh_interonset interonset)                 ;                     (kh_intersect abs_interpitch_hash (kh_intersect pitch_hash interonset_hash))                 ;                     relation                 ;                     node)                 (and *kh_contour*                      (or (equal (kh_last (or (car node) (kh_node occurrence))) *kh_root*)                          (kh_interpitch (kh_description (or (car node) (kh_node occurrence))))                          (kh_interdegree (kh_description (or (car node) (kh_node occurrence))))                          ;(kh_interonset (kh_description (or (car node) (kh_node occurrence))))                          (kh_metric (kh_description (or (car node) (kh_node occurrence)))))                      (progn (and interonset metric (kh_associative_test occurrence                                                                         (make-instance 'kh_description :kh_interpitch sign_interpitch :kh_pitch pitch :kh_metric metric :kh_interonset interonset)                                                                         (kh_intersect contour_hash (kh_intersect pitch_hash (kh_intersect interonset_hash metric_hash)))                                                                         relation                                                                         node))                             (and interonset (kh_associative_test occurrence                                                                  (make-instance 'kh_description :kh_interpitch sign_interpitch :kh_pitch pitch :kh_interonset interonset)                                                                  (kh_intersect contour_hash (kh_intersect pitch_hash interonset_hash))                                                                  relation                                                                  node))                             (and metric (kh_associative_test occurrence                                                              (make-instance 'kh_description :kh_interpitch sign_interpitch :kh_pitch pitch :kh_metric metric)                                                              (kh_intersect contour_hash (kh_intersect pitch_hash metric_hash))                                                              relation                                                              node))))                 (and (or (equal (kh_last (or (car node) (kh_node occurrence))) *kh_root*)                          (or (kh_interpitch (kh_description (or (car node) (kh_node occurrence))))                              (kh_interdegree (kh_description (or (car node) (kh_node occurrence))))))                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_interpitch signed_interpitch :kh_interdegree signed_interdegree :kh_pitch pitch )                                           (kh_intersect interpitch_hash (kh_intersect pitch_hash interdegree_hash))                                           relation                                           node))                 (and nil                      (or (not (kh_last (or (car node) (kh_node occurrence))))                          (or (kh_interpitch (kh_description (or (car node) (kh_node occurrence))))                              (kh_interdegree (kh_description (or (car node) (kh_node occurrence))))))                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_interpitch unsigned_interpitch :kh_pitch pitch :kh_interdegree unsigned_interdegree)                                           (kh_intersect abs_interpitch_hash (kh_intersect pitch_hash abs_interdegree_hash))                                           relation                                           node))                 (and (or (equal (kh_last (or (car node) (kh_node occurrence))) *kh_root*) (kh_last (or (car node) (kh_node occurrence))))                      (kh_interdegree (kh_description (or (car node) (kh_node occurrence))))                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_interdegree signed_interdegree :kh_pitch pitch )                                           (kh_intersect pitch_hash interdegree_hash)                                           relation                                           node))                 (and nil                      (or (not (kh_last (or (car node) (kh_node occurrence))))                          (kh_interdegree (kh_description (or (car node) (kh_node occurrence)))))                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_interdegree unsigned_interdegree :kh_pitch pitch)                                           (kh_intersect pitch_hash abs_interdegree_hash)                                           relation                                           node))                 (and (or (equal (kh_last (or (car node) (kh_node occurrence))) *kh_root*)                          (kh_interpitch (kh_description (or (car node) (kh_node occurrence)))))                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_interpitch signed_interpitch :kh_pitch pitch)                                           (kh_intersect pitch_hash interpitch_hash)                                           relation                                           node))                 (and nil                      (or (not (kh_last (or (car node) (kh_node occurrence))))                          (kh_interpitch (kh_description (or (car node) (kh_node occurrence)))))                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_interpitch unsigned_interpitch :kh_pitch pitch)                                           (kh_intersect pitch_hash abs_interpitch_hash)                                           relation                                           node))                 (and *kh_contour*                      (or (equal (kh_last (or (car node) (kh_node occurrence))) *kh_root*)                          (kh_interpitch (kh_description (or (car node) (kh_node occurrence))))                          (kh_interdegree (kh_description (or (car node) (kh_node occurrence)))))                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_interpitch sign_interpitch :kh_pitch pitch)                                           (kh_intersect pitch_hash contour_hash)                                           relation                                           node))                 (and interonset                      metric                      (or (equal (kh_last (or (car node) (kh_node occurrence))) *kh_root*)                          (kh_interonset (kh_description (or (car node) (kh_node occurrence)))))                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_metric metric :kh_pitch pitch :kh_interonset interonset)                                           (kh_intersect pitch_hash (kh_intersect interonset_hash metric_hash))                                           relation                                           node))                 (and interonset                      (or (equal (kh_last (or (car node) (kh_node occurrence))) *kh_root*)                          (kh_interonset (kh_description (or (car node) (kh_node occurrence)))))                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_pitch pitch :kh_interonset interonset)                                            (kh_intersect pitch_hash interonset_hash)                                           relation                                           node))                 (and metric                      (or (equal (or (car node) (kh_node occurrence)) *kh_root*)                          (kh_metric (kh_description (or (car node) (kh_node occurrence)))))                      (kh_associative_test occurrence                                           (make-instance 'kh_description :kh_pitch pitch :kh_metric metric)                                           (kh_intersect pitch_hash metric_hash)                                           relation                                           node))                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_pitch pitch)                                      pitch_hash                                      relation                                      node)))     (and *kh_transpos*          (progn ;(print 1)            (and interonset                 metric                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_interpitch signed_interpitch :kh_interdegree signed_interdegree :kh_metric metric :kh_interonset interonset)                                      (kh_intersect interpitch_hash (kh_intersect interdegree_hash (kh_intersect interonset_hash metric_hash)))                                      relation                                      node))            (and interonset                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_interpitch signed_interpitch :kh_interdegree signed_interdegree :kh_interonset interonset)                                      (kh_intersect interpitch_hash (kh_intersect interdegree_hash interonset_hash))                                      relation                                      node))            ;(print 2)            (and metric                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_interpitch signed_interpitch :kh_interdegree signed_interdegree :kh_metric metric)                                      (kh_intersect interpitch_hash (kh_intersect interdegree_hash metric_hash))                                      relation                                      node))            ;(kh_associative_test occurrence            ;                     (make-instance 'kh_description :kh_interpitch unsigned_interpitch :kh_interdegree unsigned_interdegree :kh_interonset interonset)            ;                     (kh_intersect abs_interpitch_hash (kh_intersect abs_interdegree_hash interonset_hash))            ;                     relation            ;                     node)            (and interonset                 metric                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_interdegree signed_interdegree :kh_metric metric :kh_interonset interonset)                                      (kh_intersect interdegree_hash (kh_intersect interonset_hash metric_hash))                                      relation                                      node))            ;(print 3)            (and interonset                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_interdegree signed_interdegree :kh_interonset interonset)                                      (kh_intersect interdegree_hash interonset_hash)                                      relation                                      node))            (and metric                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_interdegree signed_interdegree :kh_metric metric)                                      (kh_intersect interdegree_hash metric_hash)                                      relation                                      node))            ;(kh_associative_test occurrence            ;                     (make-instance 'kh_description :kh_interdegree unsigned_interdegree :kh_interonset interonset)            ;                     (kh_intersect abs_interdegree_hash interonset_hash)            ;                     relation            ;                     node)            (and interonset                 metric                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_interpitch signed_interpitch :kh_metric metric :kh_interonset interonset)                                      (kh_intersect interpitch_hash (kh_intersect interonset_hash metric_hash))                                      relation                                      node))            ;(print 4)            (and interonset                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_interpitch signed_interpitch :kh_interonset interonset)                                      (kh_intersect interpitch_hash interonset_hash)                                      relation                                      node))            (and metric                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_interpitch signed_interpitch :kh_metric metric)                                      (kh_intersect interpitch_hash metric_hash)                                      relation                                      node))            ;(kh_associative_test occurrence            ;                     (make-instance 'kh_description :kh_interpitch unsigned_interpitch :kh_interonset interonset)            ;                     (kh_intersect abs_interpitch_hash interonset_hash)            ;                     relation            ;                     node)            ;(print 5)            (and *kh_contour*                 (or (equal (kh_last (or (car node) (kh_node occurrence))) *kh_root*)                     (kh_interpitch (kh_description (or (car node) (kh_node occurrence))))                     (kh_interdegree (kh_description (or (car node) (kh_node occurrence))))                     ;(kh_interonset (kh_description (or (car node) (kh_node occurrence))))                     (kh_metric (kh_description (or (car node) (kh_node occurrence)))))                 (progn (and interonset metric (kh_associative_test occurrence                                                                    (make-instance 'kh_description :kh_interpitch sign_interpitch :kh_metric metric :kh_interonset interonset)                                                                    (kh_intersect contour_hash (kh_intersect interonset_hash metric_hash))                                                                    relation                                                                    node))                        (and interonset (kh_associative_test occurrence                                                             (make-instance 'kh_description :kh_interpitch sign_interpitch :kh_interonset interonset)                                                             (kh_intersect contour_hash interonset_hash)                                                             relation                                                             node))                        (and metric (kh_associative_test occurrence                                                         (make-instance 'kh_description :kh_interpitch sign_interpitch :kh_metric metric)                                                         (kh_intersect contour_hash metric_hash)                                                         relation                                                         node))))            ;(print 6)            (and (or (equal (kh_last (or (car node) (kh_node occurrence))) *kh_root*)                     (or (kh_interpitch (kh_description (or (car node) (kh_node occurrence))))                         (kh_interdegree (kh_description (or (car node) (kh_node occurrence))))))                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_interpitch signed_interpitch :kh_interdegree signed_interdegree)                                      (kh_intersect interpitch_hash interdegree_hash)                                      relation                                      node))            (and nil                 (or (not (kh_last (or (car node) (kh_node occurrence))))                     (or (kh_interpitch (kh_description (or (car node) (kh_node occurrence))))                         (kh_interdegree (kh_description (or (car node) (kh_node occurrence))))))                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_interpitch unsigned_interpitch :kh_interdegree unsigned_interdegree)                                      (kh_intersect abs_interpitch_hash abs_interdegree_hash)                                      relation                                      node))            (and (or (equal (kh_last (or (car node) (kh_node occurrence))) *kh_root*) (kh_last (or (car node) (kh_node occurrence))))                 (kh_interdegree (kh_description (or (car node) (kh_node occurrence))))                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_interdegree signed_interdegree)                                      interdegree_hash                                      relation                                      node))            (and nil                 (or (not (kh_last (or (car node) (kh_node occurrence))))                     (kh_interdegree (kh_description (or (car node) (kh_node occurrence)))))                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_interdegree unsigned_interdegree)                                      abs_interdegree_hash                                      relation                                      node))            ;(print 7)            (and (or (equal (kh_last (or (car node) (kh_node occurrence))) *kh_root*)                     (kh_interpitch (kh_description (or (car node) (kh_node occurrence)))))                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_interpitch signed_interpitch)                                      interpitch_hash                                      relation                                      node))            (and nil                 (or (not (kh_last (or (car node) (kh_node occurrence))))                     (kh_interpitch (kh_description (or (car node) (kh_node occurrence)))))                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_interpitch unsigned_interpitch)                                      abs_interpitch_hash                                      relation                                      node))            (and *kh_contour*                 (or (equal (kh_last (or (car node) (kh_node occurrence))) *kh_root*)                     (kh_interpitch (kh_description (or (car node) (kh_node occurrence))))                     (kh_interdegree (kh_description (or (car node) (kh_node occurrence)))))                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_interpitch sign_interpitch)                                      contour_hash                                      relation                                      node))            (and interonset                 metric                 (or (equal (kh_last (or (car node) (kh_node occurrence))) *kh_root*)                     (kh_interonset (kh_description (or (car node) (kh_node occurrence)))))                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_metric metric :kh_interonset interonset)                                      (kh_intersect interonset_hash metric_hash)                                      relation                                      node))            (and interonset                 (or (equal (kh_last (or (car node) (kh_node occurrence))) *kh_root*)                     (kh_interonset (kh_description (or (car node) (kh_node occurrence)))))                 (kh_associative_test occurrence (make-instance 'kh_description :kh_interonset interonset) interonset_hash relation node))            (and metric                 (or (equal (or (car node) (kh_node occurrence)) *kh_root*)                     (kh_metric (kh_description (or (car node) (kh_node occurrence)))))                 (kh_associative_test occurrence                                      (make-instance 'kh_description :kh_metric metric)                                      metric_hash                                      relation                                      node))))))(defun kh_is_prefix (prefix occurrence)   (labels ((recurs_is_prefix (o)              (and o                   (or (equal prefix o)                       (recurs_is_prefix (kh_last o))))))     (and (kh_last occurrence) (recurs_is_prefix (kh_last occurrence)))))(defun kh_associative_test (occurrence description class relation node)   (let ((new_element (kh_to relation))         (debuga 0))     (db_print "kh_associative_test" 0 (kh_address new_element))     (db_kh_print description 0 (kh_address new_element))     (and (= (kh_address new_element) debug)          (print "kh_associative_test" )          (not (kh_print occurrence))          (not (kh_print description))          (not (kh_print node))          ;(prin1 'a)          (not (loop for i in class                     do (progn (print ">")                               (kh_print (car i))                               (print (cdr i))                               (kh_print (kh_to (cadr i))))))          (print "...")          )     ;(kh_print new_element)     (setq description (kh_filter description))     (and      (not (kh_nil description (car node)))      (or (not (= (kh_address new_element) debuga))          (progn (kh_print description)                 t))      (or (not occurrence)          (equal (car node) *kh_root*)          (let ((generalized (kh_generalize occurrence node)))            (and generalized                 (or (not (= (kh_address new_element) debuga))                     (progn (kh_print generalized)                            t))                 (kh_continuous generalized description))))      (or (not (= (kh_address new_element) debuga))          (progn (kh_print description)                 t))      (not (loop for child in (kh_children (car node))                 thereis (progn (and (= (kh_address new_element) 0)                                     (progn                                       (print ">")                                       (not (kh_print child))                                       (not (kh_print description))))                                (kh_equal (kh_description child) description))))      (not (and (typep (car node) 'kh_cyclic_pattern)                (or                  (kh_equal_or_specific (kh_description (kh_next (car node))) description)                 )))      (or (not (= (kh_address new_element) debuga))          (prin1 1))      (let* ((uncyclic_class (loop for occ in (sort (copy-list class) #'< :key #'(lambda(x) (kh_address (kh_to (cadr x)))))                                   with previous = nil                                   when (if occurrence                                          (and (if (= (kh_address new_element) debug)                                                 (progn                                                   (print ">")                                                          ;(kh_print description)                                                   ;(not (kh_print occurrence))                                                   (not (kh_print (car occ)))                                                   (not (kh_print previous))                                                   t)                                                 t)                                               (let ((generalised (kh_generalize (car occ) node)))                                                 (or (not (= (kh_address new_element) debuga))                                                     (progn (print 1.0)                                                            (kh_print generalised)))                                                 (and generalised                                                      (not (kh_check_emergence generalised description)) ;(kh_description relation)))                                                      (or (not (= (kh_address new_element) debuga))                                                          (progn (print 1.1)                                                                 (kh_print generalised)                                                                 t))                                                      (or (not (= (kh_address new_element) debuga))                                                          (print 1.2))                                                      ;(not (kh_print (car (kh_enumerate generalised))))                                                                                                   (or (not (= (kh_address new_element) debuga))                                                          (print 1.3))                                                      )))                                          (or (not previous)                                              (not (equal (kh_address (kh_to (cadr occ))) previous))))                                   collect (progn                                             (setq previous (kh_address (kh_to (cadr occ))))                                             (and (= (kh_address new_element) debuga)                                                  (progn                                                    (print 1.4)                                                    (kh_print (car occ))))                                             occ)))             (card (length uncyclic_class)))        (and (or (not (= (kh_address new_element) debuga))                 (prin1 2))             (> card 1)             (or (not (= (kh_address new_element) debuga))                 (prin1 3))             ;(progn (kh_print occurrence)             ;       (kh_print (kh_node occurrence))             ;       (and (kh_cyclicp occurrence) (print (kh_next (kh_node occurrence))))             ;       t)             (not (and *kh_specif*                       (labels ((recurs_associative_test (s p processed)                                  (and (= (kh_address new_element) debuga)                                       (progn                                         ;(print "recurs_associative_test")                                         (prin1 'R)                                         (print s)                                         (print p)                                         (print processed)))                                  (let ((snode (if (typep s 'kh_pattern)                                                 s                                                 (kh_node s))))                                    (and (not (member snode processed))                                         (progn (push snode processed)                                                (or (loop for u in (kh_occurrence snode)                                                          thereis (equal (kh_param u) p))                                                    (and (not (typep s 'kh_pattern))                                                         (loop for v in (kh_specific s)                                                               thereis (recurs_associative_test v p processed)))                                                    (loop for w in (kh_general snode)                                                          thereis (recurs_associative_test (car w) p processed))                                                    )))))                                (recurs_cumul (l)                                  (if (cdr l)                                    (kh_cumul (kh_inter_description (car l)) (recurs_cumul (cdr l)))                                    (kh_inter_description (car l)))))                         (loop for specific in (kh_upto new_element)                               ;(kh_new_specific occurrence description node)                               thereis (and ;(or ;(not (= (kh_address new_element) debuga))                                        ;    (progn                                        ;      (print ">>a")                                        ;      (not (kh_print specific))))                                        ;(if (kh_last specific)  NOT CORRECT (WHAT IF INSERTED NOTE ?) AND ALREADY SUBSUMED IN NEXT TEST (WITH ENUM)                                        ;  (print (kh_equal_or_specific (kh_last specific) (car node)))                                        ;  (equal (car node) *kh_root*))                                        (or (not (= (kh_address new_element) debuga))                                            (progn                                              (print ">>b")                                              (kh_print specific)                                              t))                                        (kh_equal_or_specific (kh_note_description specific) (kh_note_description description))                                        (or (not occurrence)                                            (equal (car node) *kh_root*)                                            (and (= (kh_address new_element) debuga)                                                 (progn                                                   (kh_print (member (kh_param occurrence) (kh_enumerate specific) :key #'kh_param))                                                   nil))                                            (let ((enum (member (kh_param occurrence) (kh_enumerate specific) :key #'kh_param)))                                              (and (= (kh_address new_element) debuga)                                                   (progn                                                     (kh_print (car enum))                                                     (kh_print (kh_generalize occurrence node))))                                              (and enum                                                   ;(progn (kh_print enum) t)                                                   (if (= (kh_address new_element) debuga)                                                     (progn                                                       (print ">>c")                                                       (kh_print (recurs_cumul (cdr enum)))                                                       (kh_print (kh_inter_description description))                                                       (and (print (kh_equal_or_specific (kh_node (car enum)) (kh_node (kh_generalize occurrence node))))                                                            (print (kh_equal_or_specific (recurs_cumul (cdr enum)) (kh_inter_description description)))))                                                     (and (kh_equal_or_specific (car enum) (kh_generalize occurrence node))                                                          (kh_equal_or_specific (recurs_cumul (cdr enum)) (kh_inter_description description)))))))                                        (or (not (= (kh_address new_element) debuga))                                            (progn                                              (print ">specific")                                              ;(not (kh_print specific))                                              ;(prin1 "****specific****")                                              (prin1 'S)                                              ;(not (kh_print (kh_last specific)))                                              ;(not (kh_print (car node)))                                              ;(print card)                                              ;(print (length (recurs_associative_test specific)))                                              ))                                        (loop for occ in uncyclic_class                                              always (progn                                                       (and (= (kh_address new_element) debuga)                                                            (progn                                                              (print ">>")                                                              (kh_print (car occ))                                                              ;(prin1 "****class****")                                                              (prin1 'C)                                                              ;(kh_print (kh_to (cadr occ)))                                                              ))                                                       (recurs_associative_test specific (kh_to (cadr occ)) nil)))                                        )))))             (or (not (= (kh_address new_element) debuga))              (prin1 "****fin****"))             (or (not occurrence)                 (equal (car node) *kh_root*)                 (and (kh_generalize occurrence node)                      (not (kh_check_emergence (kh_generalize occurrence node)                                               description)))) ;(kh_description relation)))))             (or (not (= (kh_address new_element) debuga))                 (prin1 5))             (kh_develop node uncyclic_class description occurrence relation))))))(defun kh_develop (node class description occurrence relation)   (db_print "kh_develop" 0 (kh_address (kh_to relation)))   (and (= (kh_address (kh_to relation)) 0)        (progn          (setf *kh_print* 'all)          (print "kh_develop?")          (kh_print (car node))          (kh_print occurrence)          (kh_print description)          (loop for c in class                do (progn (kh_print (car c))                          (kh_print (kh_to (cadr c)))))          ))   (let ((element (kh_to relation)))     (and (or (not occurrence)               (and (not (kh_new_cycle occurrence description node relation))                   (loop for occ in class                         thereis (and ;(progn (print ">occ>")                                  ;       (kh_print (car occ)))                                  (not (and (equal (kh_to (cadr occ)) element)                                            (equal (kh_param (car occ)) (kh_param occurrence))))                                  (if (typep (or (car node) (kh_node occurrence)) 'kh_cyclic_pattern)                                    (and (progn                                       (and (= (kh_address element) 0)                                            (print ">>>1")                                            (not (kh_print (kh_to (cadr occ))))                                            (kh_print (kh_param (car (kh_enumerate_pattern occurrence node)))))                                       #|(labels ((recurs_find_old_occurrence (o n d c)           (print "recurs_find_old_occurrence")           (kh_print o)           (kh_print n)           (if (not o)                                                                                                occurrence ;pour éviter les cycles imbriqués                                                                                                (if (or ;;;;;??(equal n (car node))                                                                                                        (not (kh_last n))                                                                                                        (and (not c)                                                                                                             (kh_cyclicp n)                                                                                                             (setq c t)                                                                                                             (kh_equal_or_specific d (kh_description (kh_next n)))))                                                                                                  (progn                                                                                                    ;(print ">>")                                                                                                    ;(kh_print o)                                                                                                    o)                                                                                                  (recurs_find_old_occurrence (kh_last o) (kh_last n) (kh_description o) c)))))                                                                                     (recurs_find_old_occurrence (kh_last occurrence)                                                                                                                 (kh_last (car node))                                                                                                                 (kh_description occurrence))))))|#                                       (<= (kh_time (kh_to (cadr occ)))                                           (kh_time (kh_param (car (kh_enumerate_pattern occurrence node)))))))                                    #|(labels ((recurs_find_old_occurrence (o n d)           ;(print "recurs_find_old_occurrence")           ;(kh_print o)           ;(kh_print n)           (if (not o)                                                                                                  occurrence ;pour éviter les cycles imbriqués                                                                                                  (if (or (equal n (car node))                                                                                                          (not (kh_last n)))                                                                                                    (progn                                                                                                      ;(print ">>")                                                                                                      ;(kh_print o)                                                                                                      o)                                                                                                    (recurs_find_old_occurrence (kh_last o) (kh_last n) (kh_description o))))))                                                                                       (recurs_find_old_occurrence (kh_last occurrence)                                                                                                                   (kh_last (car node))                                                                                                                   (kh_description occurrence)))))))))|#                                    (progn                                      (and (= (kh_address element) 0)                                           (print ">>>2")                                           (not (kh_print occurrence))                                           (not (kh_print (car node)))                                           (not (kh_print (kh_to (cadr occ))))                                           (kh_print (kh_param (let* ((enumerate (kh_enumerate_pattern occurrence node))                                                                      (cyclic (loop for o on enumerate                                                                                    when (kh_cyclicp (kh_node (car o)))                                                                                    return o))                                                                      (uncyclic (loop for o on cyclic                                                                                      when (and (cdr o)                                                                                                (not (kh_cyclicp (kh_node (cadr o)))))                                                                                      return o)))                                                                 (kh_print enumerate)                                                                 (kh_print cyclic)                                                                 (kh_print uncyclic)                                                                 (if (and (print cyclic)                                                                          (print uncyclic)                                                                          ;(not (kh_print cyclic))                                                                          (kh_equal_or_specific (kh_description (cadr uncyclic)) (kh_description (kh_next (kh_node (car uncyclic))))))                                                                   (car uncyclic)                                                                   (car enumerate))))))                                      (<= (kh_time (kh_to (cadr occ)))                                          (kh_time (kh_param (let* ((enumerate (kh_enumerate_pattern occurrence node))                                                                    (cyclic (loop for o on enumerate                                                                                  when (kh_cyclicp (kh_node (car o)))                                                                                  return o))                                                                    (uncyclic (loop for o on cyclic                                                                                    when (and (cdr o)                                                                                              (not (kh_cyclicp (kh_node (cadr o)))))                                                                                    return o)))                                                               (if (and cyclic                                                                        uncyclic                                                                        (kh_equal_or_specific (kh_description (cadr uncyclic)) (kh_description (kh_next (kh_node (car uncyclic))))))                                                                 (car uncyclic)                                                                 (car enumerate))))))))))))          (let ((newnode (make-instance 'kh_pattern                           :kh_address (incf *kh_node_counter*)                           :kh_last (car node)                           :kh_description description)))            (or (member newnode (kh_acyclic_children (car node)))                (push newnode (kh_acyclic_children (car node))))            (and (= (kh_address (kh_to relation)) 0)                 (progn                   (print 'kh_develop)                   (kh_print (car node))                   (kh_print occurrence)                   (kh_print description)                   (print class)                   (kh_print newnode)))            (kh_interlink_node newnode (car node) description t)            (if nodebug              (progn                (terpri)                (terpri)                (format t "New Pattern")                (kh_print newnode)                ))            (loop for selected in (sort (copy-list class) #'< :key #'(lambda (x) (kh_time (kh_to (cadr x)))))                  do (progn (and (= (kh_address (kh_to relation)) 0)                                 (progn                                   (not (print ">>"))                                   (not (print selected))                                   (kh_print (car selected))                                   (kh_print (car node))                                   (kh_print (kh_generalize (car selected) node))))                            (let* ((oldocc (kh_generalize (car selected) node))                                   (newocc (and (or (not occurrence)                                                    oldocc)                                                (kh_instantiate_node oldocc (cadr selected) newnode t nil))))                              ;(print 1)                              (and newocc                                   (progn (loop for relation in (kh_from (kh_to (cadr selected)))                                                do (kh_memorize newocc relation (list newnode)))                                          ;(print 2)                                          (kh_interlink newocc)                                          ;(print 3)                                          (kh_check_cyclic newocc)                                          ;(print 4)                                          )))))            (terpri)                       (and nil (or (equal *kh_print* 'all)                         (equal *kh_print* 'new))                 (kh_print newnode))))))(defun kh_check_emergence (occurrence description)   (and (= (kh_address (car *kh_notes*)) 0)        (print "kh_check_emerge")        (not (kh_print occurrence))        (kh_print description))   (or (let* ((enumerate (kh_enumerate occurrence))              (cyclic (member-if #'(lambda (x) (typep (kh_node x) 'kh_cyclic_pattern)) enumerate)))         (loop for c on cyclic               thereis (let ((n nil))                         (and (= (kh_address (car *kh_notes*)) 0)                              (print ">>")                              (kh_print (car c)))                         (and (loop for o in c                                    always (progn                                             (and (= (kh_address (car *kh_notes*)) 0)                                                  (print ">")                                                  (kh_print o)                                                  (kh_print n))                                             (setq n (if n (kh_next n) (kh_node o)))                                             (and (kh_cyclicp n)                                                  (kh_equal_or_specific (kh_description o) (kh_description n)))))                              (not (kh_equal_or_specific n (kh_node occurrence)))                              (kh_next n) ;probleme des cycles en cours de formation                              (or (not (= (kh_address (car *kh_notes*)) 0))                                  (not (print "emergence cyclic!"))                                  (kh_print occurrence)                                  ;(kh_print enumerate)                                  (kh_print (car cyclic))                                  (kh_print n)                                   (not (kh_print (kh_next n))))                              (kh_equal_or_specific description (kh_description (kh_next n)))                              (kh_equal_or_less_specific description (kh_derivative_filter (kh_description n) (kh_description (kh_next n))))))))       (loop for occ in (kh_upto (kh_param occurrence))             thereis (and (or (not (= (kh_address (kh_param occurrence)) (1- 0)))                              (not (print ">"))                              (not (kh_print occ)))                          (typep (kh_node occ) 'kh_cyclic_pattern)                          (not (kh_equal_or_specific occ occurrence))                          (kh_superposed occurrence occ)                          (kh_next (kh_node occ))                          ;(print ">")                          ;(not (kh_print occ))                          (loop for n in (kh_next occ)                                thereis (kh_equal_or_specific (kh_description n) (kh_description (kh_next (kh_node occ))))                                #|(progn (print ">>")       (kh_print n)       (member (kh_node n)               (cons (kh_next (kh_node occ)) (append (kh_collect_general_cycle (kh_next (kh_node occ)))                                                     (kh_collect_specific_cycle (kh_next (kh_node occ)))))))|#)                          ;(kh_more_specific (kh_description occurrence) (kh_description (kh_node occ)))                          (kh_equal_or_less_specific description (kh_derivative_filter (kh_description (kh_node occ)) (kh_description (kh_next (kh_node occ)))))                          (progn (or (not (= (kh_address (car *kh_notes*)) 0))                                     (not (print "emergence !!"))                                     (kh_print occurrence)                                     (kh_print description)                                     (kh_print occ)                                     (not (kh_print (kh_next (kh_node occ)))))                                 t)                          occ                          ))))(defun kh_superposed (little big)   (if (and (= (kh_address little) 0)            (= (kh_address big) 0)            (print "kh_superposed")            (not (kh_print little))            (not (kh_print big)))     (labels ((recurs_superposed (l b n)                (print "recurs")                (kh_print l)                (kh_print b)                (kh_print n)                (and (print (kh_last b))                     ;(print (kh_equal_or_specific (kh_node b) n))                     (print (equal (kh_param l) (kh_param b)))                     (or (print (not (kh_last l)))                         ;(typep (kh_node (kh_last l)) 'kh_cyclic_pattern)                         (recurs_superposed (kh_last l) (kh_last b) (kh_last n))))))       (recurs_superposed little big (kh_node big)))     (labels ((recurs_superposed (l b n)                (and (kh_last b)                     ;(kh_equal_or_specific (kh_node b) n)                     (equal (kh_param l) (kh_param b))                     (or (not (kh_last l))                         ;(typep (kh_node (kh_last l)) 'kh_cyclic_pattern)                         (recurs_superposed (kh_last l) (kh_last b) (kh_last n))))))       (recurs_superposed little big (kh_node big)))))(defun kh_derivative_filter (old new)   (make-instance 'kh_description     :kh_interpitch (and (kh_interpitch old)                         (kh_interpitch new)                         (if (kh_sign (kh_interpitch old))                           (if (kh_number (kh_interpitch old))                             (kh_interpitch new)                             (kh_sign (kh_interpitch new)))                           (and (kh_number (kh_interpitch old))                                (kh_number (kh_interpitch new)))))     :kh_interdegree (and (kh_interdegree old)                          (kh_interdegree new))     :kh_interonset (and (kh_interonset old)                         (kh_interonset new))     :kh_metric (and (kh_metric old)                     (kh_metric new))     :kh_pitch (and (kh_pitch old)                    (kh_pitch new))))(defun kh_check_cyclic (newocc)   (db_print "kh_check_cyclic" 0 (kh_address (car *kh_notes*)))   (if (= (kh_address (car *kh_notes*)) 0)     (progn       (print "kh_check_cyclic")       (kh_print newocc)))   ;(kh_print newocc)   (and (not (kh_cyclicp newocc))        (let ((processed nil))          (labels ((recurs_check_cyclic (o)                     (if (= (kh_address (car *kh_notes*)) 0)                       (progn                         (print "recurs_check_cyclic")                         (kh_print o)                         ))                     (and (not (member (car o) processed))                          (push (car o) processed)                          (or (loop for s in (kh_specific (car o))                                    thereis (and ;(print ">s")                                             ;(not (kh_print s))                                             (not (member (car s) (kh_general (car o)) :key #'car))                                             (kh_equal_or_specific newocc (car s))                                             (= (kh_acyclic_level (car o)) (kh_acyclic_level (car s)))                                             (recurs_check_cyclic (list (car s) (kh_syntag_prod (cadr s) (cadr o))))))                              (and (kh_last (car o))                                   (or (kh_check_cyclic_each newocc o)                                       (loop for g in (sort (copy-list (kh_general (car o))) #'kh_equal_or_specific :key #'car)                                             when (and (or (not (= (kh_address (car *kh_notes*)) 0))                                                           (progn (print ">>>")                                                                  (kh_print g)                                                                  t))                                                       (not (member (car g) (kh_specific (car o)) :key #'car))                                                       ;(= (kh_acyclic_level (car o)) (kh_acyclic_level (car g)))                                                       )                                             do (recurs_check_cyclic (list (car g) (kh_syntag_prod (cadr o) (cadr g)))))))))))            (recurs_check_cyclic (list (kh_node newocc) (kh_count (kh_node newocc))))))        (db_print "ok_check_cyclic" 0 (kh_address (kh_param newocc)))))(defun kh_check_cyclic_each (createdocc node)   (if (= (kh_address (car *kh_notes*)) 0)     (progn       ;(setf *kh_print* 'all)       (print "kh_check_cyclic_each")       (kh_print createdocc)       (kh_print (car node))       ))   (and (not (typep (car node) 'kh_cyclic_pattern))        (let* ((enumerate (kh_enumerate_pattern createdocc node))               (occ (and (cdr enumerate)                         ;(print ">>")                         ;(progn (kh_print enumerate) t)                         (loop for oc in (kh_upto (kh_param createdocc))                               thereis (and (kh_equal_or_specific oc (car node))                                            ;(print ">>>")                                            ;(not (kh_print oc))                                            ))                         ;(kh_equal_or_specific (car node) (kh_node createdocc))                         (kh_equal_or_specific (kh_node createdocc) (car node))                         ;(progn (kh_print enumerate)                         ;       t)                      (or (not (kh_metric (car node)))                          (equal (kh_metric (car node))                                 (kh_metric (kh_node (first enumerate)))))                      (or (not (kh_pitch (car node)))                          (equal (kh_pitch (car node))                                 (kh_pitch (kh_node (first enumerate)))))                          (kh_most_general (loop for oc in (kh_upto (kh_param (first enumerate)))                                                 append (let ((res (and                                                                    (progn (if (= (kh_address (car *kh_notes*)) 0)                                                                             (progn                                                                               (print ">")                                                                               (kh_print oc)                                                                               (print (kh_equal_or_specific (kh_node oc) (car node)))))                                                                           (kh_equal_or_specific (kh_node oc) (car node)))                                                                    ;(print ">")                                                                    ;(not (kh_print oc))                                                                    )))                                                          (and res                                                               (list (list oc res)))))))))          (and occ               (or (not (= (kh_address (car *kh_notes*)) 0))                   (progn                     (print ">>kh_check_cyclic_each")                     (kh_print createdocc)                     (kh_print (car node))                     (kh_print (first enumerate))                     (kh_print (car occ))                     (kh_print (cadr enumerate))                     (kh_print (cadr (kh_enumerate (car node))))                     t                     ))               (or (kh_decontext (car node))                   (loop for o in (kh_upto (kh_param createdocc))                         thereis (and (progn (and  (= (kh_address (car *kh_notes*)) 0)                                                   (print "?")                                                   (kh_print o))                                             t)                                      (loop for g in (cons (list (kh_node o)) (kh_all_general o))                                            thereis (and (progn (and  (= (kh_address (car *kh_notes*)) 0)                                                                      (print "???")                                                                      (kh_print g))                                                                t)                                                         (typep (car g) 'kh_cyclic_pattern)                                                         (kh_equal_period (car g) (car node))                                                         ;(print "!!!")                                                         ;(not (kh_print o))                                                         ))))                   (let ((generalized (kh_generalize (caar occ) (list (car node) (cadar occ)))))                     ;(print "#")                     ;(kh_print generalized)                     (and generalized                          (or (and (cadr enumerate)                                   (kh_check_emergence generalized (kh_description (cadr enumerate))))                              (kh_create_cycle node generalized (kh_generalize createdocc node))))))))))(defmethod kh_decontext ((pattern kh_pattern))   ;(print "decontext")   ;(kh_print pattern)   (or (kh_cyclicp pattern)       (labels ((recurs_context (p d)                  ;(print "recurs_context")                  ;(kh_print p)                  ;(kh_print d)                  (and p                       (append (if (kh_cyclicp p)                                 (and (not (kh_equal_or_specific d (kh_description (kh_next p))))                                      (list t))                                 (recurs_context (kh_last p) (kh_description p) ))                               (list p))))                (recurs_decontext (p g)                  ;(print "recurs_decontext")                  ;(kh_print p)                  ;(kh_print g)                  (and (not (kh_cyclicp g))                       (if (not (kh_last g))                         p                         (and (kh_equal (kh_description p) (kh_description g))                              (recurs_decontext (kh_last p) (kh_last g)))))))         (let* ((contexts (recurs_context pattern nil))                (context (car contexts)))           ;(print "context")           ;(kh_print context)           (if (equal context t)             (member (kh_description (second (kh_enumerate pattern))) (kh_children pattern) :key #'kh_description)             (loop for g in (kh_general pattern)                   when (equal (recurs_decontext pattern (car g)) context)                   return (progn                            ;(print ">>")                            ;(kh_print (car g))                            (member (kh_description (second (kh_enumerate (car g)))) (kh_children (car g)) :key #'kh_description))                   finally return (member (kh_description (cadr contexts)) (kh_children pattern) :key #'kh_description)))))))(defun kh_create_cycle (node oldocc newocc)   (db_print "kh_create_cycle" 0 (kh_address (car *kh_notes*)))   (let ((debug 0))     (if (= (kh_address (car *kh_notes*)) debug)       (progn         (setf *kh_print* 'all)         (print "kh_create_cycle")         (kh_print node)         (kh_print oldocc)         (kh_print newocc)         ))     (let ((second nil))       (and oldocc            newocc            (not (loop for n in (kh_children (car node))                       thereis (and (kh_cyclicp n)                                    ;(print "!!")                                    )))            (let* ((counter (incf *kh_cyclic_counter*))                   (pos -1)                   (finals (labels ((recurs_change_begin_cycle (o)                                      (if (= (kh_address (car *kh_notes*)) debug)                                        (progn                                          (print "recurs_change_begin_cycle")                                          (kh_print o)))                                      (let ((last (and (kh_last o)                                                       (recurs_change_begin_cycle (kh_last o)))))                                        (if last                                          (or (loop for next in (kh_next last)                                                    when (kh_equal (kh_description next) (kh_description o))                                                    return next)                                              (let ((nextnode (or (loop for next in (kh_children (kh_node last))                                                                        when (kh_equal (kh_description next) (kh_description (kh_node o)))                                                                        return next)                                                                  (let ((newnode (make-instance 'kh_pattern                                                                                   :kh_address (incf *kh_node_counter*)                                                                                   :kh_last (kh_node last)                                                                                   :kh_description (kh_description (kh_node o)))))                                                                    (kh_interlink_node newnode (kh_node last) (kh_description (kh_node o)) t)                                                                    (if t ;nodebug                                                                      (progn                                                                        (print 'kh_create_cycle2)                                                                        (kh_print newnode)))                                                                    newnode                                                                    ))))                                                (kh_generalize o (list nextnode (kh_count nextnode)))))                                          (let ((i (kh_intersect_description (car node) (kh_node o))))                                            (or (loop for g in (kh_generals (list (kh_node o) (kh_count (kh_node o))))                                                      when (equal (kh_note_description (car g)) (kh_note_description i))                                                      return (progn                                                               ;(print "node already created !")                                                               ;(kh_print g)                                                               (list (kh_generalize o g) g)))                                                (let ((newnode (make-instance 'kh_pattern                                                                 :kh_address (incf *kh_node_counter*)                                                                 :kh_last (kh_last (kh_node o))                                                                 :kh_description i)))                                                  ;(kh_print newnode)                                                  (kh_interlink_node newnode (kh_last (kh_node o)) i t)                                                  (if nodebug                                                    (progn                                                      (print 'kh_create_cycle)                                                      (kh_print newnode)))                                                  (kh_generalize o (list newnode (kh_count newnode)))))))))                                    (recurs_check_cyclic_each (o d c)                                      (if (= (kh_address (car *kh_notes*)) debug)                                        (progn                                          (print "recurs_check_cyclic_each")                                          (kh_print o)                                          (kh_print d)                                          (print c)))                                      (if (or (equal (kh_param o) (kh_param oldocc))                                              (and (not c)                                                   (kh_cyclicp o)                                                   (setq c t)                                                   (kh_equal_or_specific d (kh_description o)))                                              (equal (kh_node o) *kh_root*))                                        (progn ;(kh_print oldocc)                                          (list (let ((res (if (kh_equal (kh_note_description (car node)) (kh_note_description o))                                                             oldocc                                                             (and ;(print "change of beginning of cycle !")                                                              (recurs_change_begin_cycle oldocc)))))                                                  ;(print ">>>")                                                  ;(kh_print res)                                                  res)                                                t))                                        (let* ((lasts (recurs_check_cyclic_each (kh_last o) (kh_description o) c))                                               (last (car lasts))                                               (newnode (make-instance 'kh_cyclic_pattern                                                          :kh_address counter                                                          :kh_pos (incf pos)                                                          :kh_last (if (not (kh_last (kh_node (kh_last o))))                                                                     (car node)                                                                     (kh_node last))                                                          :kh_description (kh_description o)                                                          :kh_cycle_frame (kh_node o)))                                               (emergence nil)                                               (newoccurrence (if emergence                                                                (progn                                                                  (print "cycling interrupted by emergence")                                                                  ;(kh_print last)                                                                  (kh_print newnode)                                                                  (kh_print emergence)                                                                  (throw 'emergence nil))                                                                (kh_instantiate_node last (kh_relation o) newnode nil nil))))                                          (if (= (kh_address (car *kh_notes*)) debug)                                            (progn                                              (print ">>>")                                              (kh_print o)                                              ;(kh_print (kh_last (kh_node o)))                                              (kh_print last)                                              (kh_print newnode)                                              (kh_print (if (not (kh_last (kh_node (kh_last o))))                                                          (car node)                                                          (kh_node last)))                                              (kh_print newoccurrence)                                              ))                                          (labels ((rec (n)                                                     (if (= (kh_address (car *kh_notes*)) debug)                                                       (progn                                                         (print "rec")                                                         (kh_print n)))                                                     (loop for oc in (kh_occurrence n)                                                           do (progn (if (= (kh_address (car *kh_notes*)) debug)                                                                       (progn                                                                         (print ">")                                                                         (not (kh_print oc))                                                                         (not (kh_print newnode))                                                                         (not (kh_print (kh_param oc)))                                                                         (print (kh_upto (kh_param oc)))))                                                                     (and (not (member (kh_last newnode) (kh_upto (kh_param oc)) :key #'kh_node :test #'kh_equal_or_less_specific))                                                                          (loop for next in (kh_from (kh_to (kh_relation oc)))                                                                                do (progn (if (= (kh_address (car *kh_notes*)) debug)                                                                                            (progn                                                                                              (print "<")                                                                                              (not (kh_print next))                                                                                              (not (kh_print newnode))))                                                                                          (and (kh_equal_or_specific (kh_description next) (kh_description newnode))                                                                                               (let ((modoc (if (equal n (kh_last newnode))                                                                                                              oc                                                                                                              (kh_generalize oc (list (kh_last newnode) (kh_count (kh_last newnode)))))))                                                                                                 (and modoc                                                                                                      (kh_instantiate_node modoc next newnode nil nil)))))))))                                                     (loop for s in (kh_specific n)                                                           do (rec (car s)))))                                            (rec (kh_last newnode)))                                          ;(kh_print (kh_last o))                                          ;(print 1)                                          (if (cadr lasts)                                            ;(or (and (not c)                                            ;         (kh_cyclicp (kh_last o))                                            ;         (kh_equal_or_specific (kh_description o) (kh_description (kh_last o))))                                            ;    (equal (kh_last (kh_node (kh_last o))) *kh_root*))                                            (progn                                              ;(print "YES")                                              ;(kh_print (kh_node o))                                              (setq second newoccurrence)                                              (push newnode (kh_cyclic_children (car node)))                                              (setf (kh_acyclic_last newnode) (car node)))                                            (progn                                              ;(print ">")                                              ;(kh_print (print (kh_node last)))                                              ;(kh_print (print newnode))                                              (setf (kh_next (kh_node last)) newnode)))                                          ;(print 2)                                          (loop for relation in (kh_from (kh_param o))                                                do (kh_memorize newoccurrence relation (list newnode)))                                          ;(print 'd)                                          (kh_interlink_node newnode (kh_node last) (kh_description o) nil)                                          ;(print 'e)                                          (if (not (member newnode (kh_specific (kh_node o)) :key #'car))                                            (push (list newnode (kh_count (kh_node o))) (kh_specific (kh_node o))))                                          ;(print 'f)                                          (if (not (member (kh_node o) (kh_general newnode) :key #'car))                                            (push (list (kh_node o) (kh_count (kh_node o))) (kh_general newnode)))                                          ;(print 'g)                                          (kh_interlink newoccurrence)                                          ;(print 'h)                                          (list newoccurrence nil)))))                             ;(print "cyclic")                             ;(kh_print newocc)                             ;(kh_print oldocc)                             (catch 'emergence (recurs_check_cyclic_each newocc nil nil))))                   (final (car finals)))              (if (= (kh_address (car *kh_notes*)) debug)                (progn                  (print "last>")                                  (and (print second) (kh_print (kh_node second)))                  (and (print final) (kh_print (kh_node final)))))              (and final                   (progn (setf (kh_next (kh_node final)) (kh_node second))                          (push (kh_node second) (kh_cyclic_children (kh_cycle_frame (kh_node final))))                          (setf (kh_acyclic_last (kh_node second)) (kh_cycle_frame (kh_node final)))                          (setf (kh_last (kh_node second)) (kh_node final))                          ;(print 1)                          (kh_check_link (kh_node final))                          ;(print 2)                          (kh_interlink_cycle (kh_node final))                                                    (and ;nil                               (labels ((recurs_mamux_create_cycle (c c0)                                          (and nil ;debug                                               (print "recurs_mamux_create_cycle")                                               (progn                                                  (kh_print c)                                                 (kh_print c0)))                                          (loop for g in (kh_general_cycle c)                                                when (and (kh_equal_or_specific (kh_next c) (kh_next g))                                                          (not (member (kh_next g) (kh_general_cycle (kh_next c))))                                                          (not (equal g c)))                                                do (progn                                                     (print "MAMUX CREATE CYCLE !! ! ! !   !")                                                     (push (kh_next g) (kh_general_cycle (kh_next c)))))                                          (or (equal (kh_next c) c0)                                              (recurs_mamux_create_cycle (kh_next c) c0))))                                 (recurs_mamux_create_cycle  (kh_node final)  (kh_node final))))                                                    (terpri)                          (terpri)                          (format t "New cyclic pattern")                          (kh_print final)                          (kh_print (kh_node second))                          (terpri)                          ;(print 'ok)                          ;(kh_print (kh_cycle_frame (kh_node second)))                          )))))))(defun kh_check_link (node)   (labels ((recurs_check_link (n)              (loop for s in (kh_specific n)                    when (not (kh_equal_or_specific (car s) n))                    do (progn                         (setf (kh_specific n) (delete (car s) (kh_specific n) :test #'equal :key #'car))                         (setf (kh_general (car s)) (delete n (kh_general (car s)) :test #'equal :key #'car))))              (loop for g in (kh_general n)                    when (not (kh_equal_or_specific n (car g)))                    do (progn                         (setf (kh_general n) (delete (car g) (kh_general n) :test #'equal :key #'car))                         (setf (kh_specific (car g)) (delete n (kh_specific (car g)) :test #'equal :key #'car))))              (if (not (equal (kh_last n) node))                (recurs_check_link (kh_last n)))))     (recurs_check_link node)))(defun kh_superposed_period (occurrence next_desc cycle)           ;(print "kh_superposed_period")   ;(kh_print occurrence)   ;(kh_print cycle)   (and occurrence        (kh_equal_or_specific next_desc (kh_description (kh_next cycle)))        (labels ((recurs_superposed_period (o n)                   ;(print "recurs_superposed_period")                   ;(kh_print o)                   ;(kh_print n)                   (or (and (equal n cycle) ;(kh_next cycle))                            (not (equal o occurrence)))                       (and (kh_equal_or_specific (kh_description o) (kh_description n))                            (recurs_superposed_period (kh_last o) (kh_last n))))))          (recurs_superposed_period occurrence cycle))))(defun kh_superposed_suffix_period (o1 o2 c)           (and (equal (kh_address o1) 0)        (progn          (print "kh_superposed_suffix_period")          (kh_print o1)          (kh_print o2)))   (labels ((recurs_superposed_suffix_period (o p m n)              (and (equal (kh_address o1) 0)                   (progn                     (print "recurs_suffix_superposed_period")                     (kh_print o)                     (kh_print p)                     (kh_print m)                     (kh_print n)))              (if (and ;(not (equal o o1))                   (equal (kh_last m) (kh_node o1)))                (equal (kh_last n) c)                (and (kh_equal_or_specific (kh_description o) (kh_description p))                     (kh_last o)                     (kh_last p)                     (recurs_superposed_suffix_period (kh_last o) (kh_last p) (kh_last m) (kh_last n))))))     (recurs_superposed_suffix_period o1 o2 (kh_node o1) c)))(defun kh_equal_period (c d)     ;(print "kh_equal_period?")   ;(kh_print c)   ;(kh_print d)   (labels ((recurs_equal_period (o n)              (and (kh_equal (kh_description o) (kh_description n))                   (kh_last o)                   (kh_last n)                   (or (and (equal (kh_last o) c)                            (if (kh_cyclicp d)                              (equal (kh_last n) d)                              (equal (kh_last (kh_last n)) *kh_root*)))                       (recurs_equal_period (kh_last o) (kh_last n))))))     (recurs_equal_period c d)))(defun kh_equal_length_period (cycle occ)           (labels ((recurs_equal_length_period (c o)              (and o                   (if (equal c cycle) ;(kh_next cycle))                     (progn                       ;(print ">>")                       ;(kh_print c)                       ;(kh_print o)                       (not (kh_last (kh_node o))))                     (recurs_equal_length_period (kh_last c) (kh_last o))))))     (recurs_equal_length_period (kh_last cycle) (kh_last occ))))(defun kh_equal_length_period2 (cycle1 cycle2)           (labels ((recurs_equal_length_period2 (c d)              (if (or (equal c cycle1)                      (equal d cycle2))                (and (equal c cycle1)                     (equal d cycle2))                (recurs_equal_length_period2 (kh_last c) (kh_last d)))))     (recurs_equal_length_period2 (kh_last cycle1) (kh_last cycle2))))(defun kh_inf_length_period (cycle occ)           ;(print "kh_inf_length_period")   ;(kh_print cycle)   ;(kh_print occ)   (labels ((recurs_inf_length_period (c o)              ;(print "recurs_inf_length_period")              ;(kh_print c)              ;(kh_print o)              (and o                   (or (equal c cycle)                       (recurs_inf_length_period (kh_last c) (kh_last o))))))     (recurs_inf_length_period (kh_last cycle) (kh_last occ))))(defun kh_new_phase (occurrence specific_child relation description)   ;(print "kh_new_phase")   ;(kh_print occurrence)   ;(kh_print specific_child)   (and occurrence        (typep specific_child 'kh_cyclic_pattern)        (or (and (kh_superposed_period occurrence (kh_description relation) (kh_last specific_child))                 (progn                   ;(print "new phase !!!")                   ;(kh_print occurrence)                   ;(kh_print specific_child)                   (let ((newoccurrence (kh_instantiate_node occurrence relation specific_child t nil)))                     (kh_interlink newoccurrence))                   (push specific_child (kh_cyclic_children (kh_node occurrence)))                   (setf (kh_acyclic_last specific_child) (kh_node occurrence))                   1))            (and (kh_inf_length_period specific_child occurrence)                 2)            )))(defun kh_change_cycle (description node sense new)   (db_print "kh_change_cycle" 0 (kh_address (car *kh_notes*)))     (print "kh_change_cycle")   (kh_print node)   (kh_print description)   (print sense)   (print new)   (let* ((debug (= (kh_address (car *kh_notes*)) 0))          (node0 nil)          (linked_frame nil)          (update (and sense (equal sense new)))          (counter (if update                     *kh_cyclic_counter*                     (incf *kh_cyclic_counter*)))          (resurs (labels ((recurs_change_cycle (n)                             (and debug                                  (print "recurs_change_cycle")                                  (not (kh_print n))                                  (kh_print (kh_cycle_frame n)))                             (if (or (equal (kh_last n) node)                                     (member (kh_last n) (kh_all_specific_cycle node)))                               (let* ((last_frame (if (not (kh_last (kh_last (kh_cycle_frame n))))                                                    (kh_last (kh_cycle_frame n))                                                    (if (not (kh_continuous (kh_last (kh_cycle_frame n)) description))                                                      *kh_root*                                                      (kh_last (kh_cycle_frame n)))))                                      (newframe (or (car (member description (kh_children last_frame) :key #'kh_description :test #'kh_equal))                                                    (let ((newf (make-instance 'kh_pattern                                                                  :kh_address (incf *kh_node_counter*)                                                                  :kh_last last_frame                                                                  :kh_description description)))                                                      (or (member newf (kh_acyclic_children last_frame))                                                          (push newf (kh_acyclic_children last_frame)))                                                      (if nodebug                                                        (progn                                                          (print 'kh_change_cycle)                                                          (kh_print newf)))                                                      (kh_interlink_node newf last_frame description t)                                                      ;(kh_print newf)                                                      newf)))                                      (before_update ;(if update                                       (kh_cycle_frame n)                                       ;newframe)                                       )                                      (newnode (if update                                                 (progn (setf (kh_description n) description)                                                        (if (equal sense 'specify)                                                          (progn (loop for s in (kh_specific n)                                                                       do (remove n (kh_general (car s)) :key #'car))                                                                 (setf (kh_specific n) nil))                                                          (progn (remove n (kh_specific (kh_cycle_frame n)) :key #'car)                                                                 (loop for g in (kh_general n)                                                                       do (remove n (kh_specific (car g)) :key #'car))                                                                 (setf (kh_general n) nil)))                                                        (setf (kh_cycle_frame n) newframe)                                                        n)                                                 (make-instance 'kh_cyclic_pattern                                                   :kh_address counter                                                   :kh_pos 0                                                   :kh_last nil                                                   :kh_description description                                                   :kh_cycle_frame newframe))))                                 (setq node0 newnode)                                 (if (not (member newnode (kh_specific newframe) :key #'car))                                   (push (list newnode (kh_count newframe)) (kh_specific newframe)))                                 (if (not (member newframe (kh_general newnode) :key #'car))                                   (push (list newframe (kh_count newframe)) (kh_general newnode)))                             (and debug                                  (print "there1")                                  (progn                                    (kh_print last_frame)                                    (kh_print newframe)                                    (kh_print newnode)))                                  (list newnode newframe t before_update))                               (let* ((last_recurs (recurs_change_cycle (kh_last n)))                                      (last (car last_recurs))                                      (last_frame (cadr last_recurs))                                      (last_before_update (cadddr last_recurs))                                      (frame_continue (progn                                                        (and debug (progn (print "frame_continue ?")                                                                          (kh_print (kh_cycle_frame n))                                                                          (kh_print last_before_update)                                                                          (kh_print (if (typep last_before_update 'kh_cyclic_pattern)                                                                                      (cons (kh_next last_before_update)                                                                                            (kh_children last_before_update))                                                                                      (kh_children last_before_update)))))                                                        (member (kh_cycle_frame n)                                                                (if (typep last_before_update 'kh_cyclic_pattern)                                                                  (cons (kh_next last_before_update)                                                                        (kh_children last_before_update))                                                                  (kh_children last_before_update)))))                                      (frame_incompleted (and (caddr last_recurs) frame_continue))                                      (newframe (and last_frame                                                     (if (not frame_incompleted)                                                       (kh_cycle_frame n)                                                       (or (car (member (kh_description n) (kh_children last_frame) :key #'kh_description :test #'kh_equal))                                                           (let ((newf (make-instance 'kh_pattern                                                                         :kh_address (incf *kh_node_counter*)                                                                         :kh_last last_frame                                                                         :kh_description (kh_description n))))                                                             (or (member newf (kh_acyclic_children last_frame))                                                                 (push newf (kh_acyclic_children last_frame)))                                                             (if nodebug                                                               (progn                                                                 (print 'kh_change_frame)                                                                 (kh_print newf)))                                                             (kh_interlink_node newf last_frame (kh_description n) t)                                                             newf)))))                                      (before_update ;(if update                                       (kh_cycle_frame n)                                       ;newframe)                                       )                                      (newnode (if update                                                 (progn (if (equal sense 'specify)                                                          (progn (loop for s in (kh_specific n)                                                                       do (remove n (kh_general (car s)) :key #'car))                                                                 (setf (kh_specific n) nil))                                                          (progn (and newframe                                                                      (remove n (kh_specific (kh_cycle_frame n)) :key #'car))                                                                 (loop for g in (kh_general n)                                                                       do (remove n (kh_specific (car g)) :key #'car))                                                                 (setf (kh_general n) nil)))                                                        (and newframe (setf (kh_cycle_frame n) newframe))                                                        n)                                                 (make-instance 'kh_cyclic_pattern                                                   :kh_address counter                                                   :kh_pos (1+ (kh_pos last))                                                   :kh_last last                                                   :kh_description (kh_description n)                                                   :kh_cycle_frame (or newframe (kh_cycle_frame n))))))                             (and debug                                  (print "there")                                  (progn                                    (kh_print last_frame)                                    (kh_print newframe)                                    (kh_print newnode)))                                  (and frame_incompleted                                       (or (member newframe (kh_acyclic_children last_frame))                                           (push newframe (kh_acyclic_children last_frame))))                                  (if (not frame_continue)                                    (progn                                 (push newnode (kh_cyclic_children last_frame))  ;A GENERALISER POUR UPDATE ??                                 (setf (kh_acyclic_last newnode) last_frame)                                       (and debug (print 'g))                                       (kh_interlink_node newnode last_frame (kh_description n) nil)                                       (setq linked_frame t)                                       (and debug                                            (print "not frame_continue")                                            (progn (kh_print newnode)                                                   (kh_print last_frame)))                                       )                                    (progn                                      (and debug (print 'h))                                      (if frame_incompleted                                        (kh_interlink_node newframe last_frame (kh_description n) t)                                        (kh_interlink_node newnode last (kh_description n) nil))))                                  (or update (setf (kh_next last) newnode))                                  (and debug                                       (print "!!")                                       (progn (kh_print newnode)                                              (kh_print n)                                              (kh_print last)))                                  ;(kh_interlink_node newnode last (kh_description n))                                  (if (not (member newnode (kh_specific newframe) :key #'car))                                    (push (list newnode (kh_count newframe)) (kh_specific newframe)))                                  (if (not (member newframe (kh_general newnode) :key #'car))                                    (push (list newframe (kh_count newframe)) (kh_general newnode)))                                  (or update                                      (if (equal sense 'generalize)                                        (progn                                          (push n (kh_specific_cycle newnode))                                          (push newnode (kh_general_cycle n))                                          (loop for g in (kh_general_cycle n)                                                when (and (kh_equal_or_specific newnode g)                                                          (not (equal g newnode)))                                                do (progn                                                     (push g (kh_general_cycle newnode))                                                     (push newnode (kh_specific_cycle g)))))                                        (if (equal sense 'specify)                                          (progn                                            (push n (kh_general_cycle newnode))                                            (push newnode (kh_specific_cycle n))                                            (loop for s in (kh_specific_cycle n)                                                  when (and (kh_equal_or_specific s newnode)                                                            (not (equal s newnode)))                                                  do (progn                                                       (push s (kh_specific_cycle newnode))                                                       (push newnode (kh_general_cycle s))))))))                                  (list newnode newframe frame_incompleted before_update)))))                    (recurs_change_cycle node)))          (node1 (car resurs)))     (and debug          (print "frame")          (progn             (kh_print (cadr resurs))            (kh_print node0)            (print linked_frame)))     (if (not linked_frame)       (progn         (push node0 (kh_cyclic_children (cadr resurs)))         (setf (kh_acyclic_last node0) (cadr resurs))))     (or update         (progn (setf (kh_last node0) node1)                (setf (kh_next node1) node0)))     (or update         (if (equal sense 'generalize)           (progn             (push node (kh_specific_cycle node1))             (push node1 (kh_general_cycle node)))           (if (equal sense 'specify)             (progn               (push node (kh_general_cycle node1))               (push node1 (kh_specific_cycle node))))))     (labels ((recurs_finish_interlink_node (n)                (and debug                     (print "recurs_finish_interlink_node")                     (progn                        (kh_print n)                       (kh_print (kh_cycle_frame (kh_next n)))))                (or (not (member (kh_cycle_frame (kh_next n)) (kh_children (kh_cycle_frame n))))                    (progn                      (and debug (print 'i))                      (kh_interlink_node (kh_next n) n (kh_description (kh_next n)) nil)                      (recurs_finish_interlink_node (kh_next n))))))       (if (caddr resurs)         (progn           (and debug (print 'j))           (kh_interlink_node node0 (kh_cycle_frame node1) description t)           (recurs_finish_interlink_node node0))         (recurs_finish_interlink_node node1)))          (labels ((recurs_mamux_change_cycle (g s g0)                (if (not (equal sense 'specify))                  (if (and (kh_equal_or_specific s g)                           (not (member g (kh_general_cycle s))))                    (progn                       (push g (kh_general_cycle s))                      (push s (kh_specific_cycle g)))))                (and debug                     (print "recurs_mamux_change_cycle")                     (progn                        (kh_print g)                       (kh_print s)                       (kh_print g0)))                (if (equal sense 'generalize)                  (loop for gg in (kh_general_cycle s)                        when (and (kh_equal_or_specific g gg)                                  (not (equal gg g))                                  (not (member gg (kh_general_cycle g))))                        do (progn (push gg (kh_general_cycle g))                                  (push g (kh_specific_cycle gg)))))                (or (equal (kh_next g) g0)                    (recurs_mamux_change_cycle (kh_next g) (kh_next s) g0))))       (recurs_mamux_change_cycle node1 node node1))          (and debug          (print "specific")          (print "general")          (kh_print node0))     ;(or update     ;    (if (equal sense 'generalize)     ;      (progn     ;        (push (kh_next node) (kh_specific_cycle node0))     ;        (push node0 (kh_general_cycle (kh_next node))))     ;      (if (equal sense 'specify)     ;        (progn     ;          (push (kh_next node) (kh_general_cycle node0))     ;          (push node0 (kh_specific_cycle (kh_next node)))))))(kh_check_link node1)     (and update debug (print "updated!!!"))     (and (equal *kh_print* 'all)          (not (kh_print node0))          ;(not (kh_print (kh_cycle_frame node0)))          )     (and debug          (print "kh_changed_cycle")          (progn (kh_print node)                 (kh_print node0)                 (kh_print (kh_cycle_frame node0))))     node0))(defun kh_general_cycles (node)   (let ((general_cycles nil))     (labels ((recurs_general_cycles (n)                ;(print "recurs_general_cycles")                ;(kh_print n)                (loop for g in (kh_general_cycle n)                      when (not (member g general_cycles))                      do (progn                           ;(print ">>")                           ;(kh_print g)                           (push g general_cycles)                           (recurs_general_cycles g)))))       (recurs_general_cycles node)       general_cycles)))(defun kh_generalize_cycle (description occurrence relation)   (db_print "kh_generalize_cycle" 0 (kh_address (kh_to relation)))      ;(print "kh_generalize_cycle")   ;(kh_print occurrence)   ;(kh_print (kh_node occurrence))   ;(kh_print description)   (let* ((new nil)          (oldoccurrence (car (kh_most_general (loop for o in (kh_upto (kh_param occurrence))                                                     when (and ;(print ">")                                                               ;(not (kh_print o))                                                               ;(not (kh_print occurrence))                                                               (typep (kh_node o) 'kh_cyclic_pattern)                                                               (kh_superposed_suffix_period o occurrence (kh_node occurrence))                                                               (kh_equal_or_specific (kh_description (kh_next (kh_node o))) description))                                                     collect o))))          (thenode (and oldoccurrence                        (or (and (kh_cyclicp occurrence)                                 (car (member description (kh_general_cycles (kh_next (kh_node occurrence))) :key #'kh_description :test #'kh_equal)))                            (let ((newcycle (kh_change_cycle description (kh_node occurrence) 'generalize (kh_new oldoccurrence))))                              (setq new 'generalize)                              newcycle))))          (newoccurrence (and oldoccurrence                              (kh_instantiate_node oldoccurrence relation thenode t new))))     ; mettre a jour les associatives memories ?     (and oldoccurrence          (progn            (kh_interlink newoccurrence)            (kh_interlink_cycle thenode)            ;(print "okok")            thenode))))(defun kh_generalize_general_cycle (node next description context)   ;(print "kh_generalize_general_cycle")   ;(kh_print node)   ;(kh_print next)   ;(kh_print description)   ;(kh_print context)   (let* ((node0 nil)          (counter (incf *kh_cyclic_counter*))          (resurs (labels ((recurs_generalize_cycle (m)                             ;(print "recurs_generalize_general_cycle")                             ;(kh_print m)                             (if (or (equal (kh_last m) (kh_last next))                                     (member (kh_last m) (kh_all_specific_cycle (kh_last next))))                               (let* ((last_frame (if (not (kh_last (kh_last (kh_cycle_frame m))))                                                    (kh_last (kh_cycle_frame m))                                                    (if (not (kh_continuous (kh_last (kh_cycle_frame m)) description))                                               *kh_root*                                                       (kh_cycle_frame (kh_last next)))))                                      (newframe (or (car (member description (kh_children last_frame) :key #'kh_description :test #'kh_equal))                                                    (let ((newf (make-instance 'kh_pattern                                                                  :kh_address (incf *kh_node_counter*)                                                                  :kh_last last_frame                                                                  :kh_description description)))                                                      (or (member newf (kh_acyclic_children last_frame))                                                          (push newf (kh_acyclic_children last_frame)))                                                      (if nodebug                                                        (progn                                                          (print 'kh_generalize_general_cycle)                                                          (kh_print newf)))                                                      (kh_interlink_node newf last_frame description t)                                                      newf)))                                      (newnode (make-instance 'kh_cyclic_pattern                                                 :kh_address counter                                                 :kh_pos 0                                                 :kh_last nil                                                 :kh_description description                                                 :kh_cycle_frame newframe)))                                 ;(kh_print last_frame)                                 ;(kh_print newframe)                                 ;(kh_print newnode)                                 (setq node0 newnode)                                 (if (not (member newnode (kh_specific newframe) :key #'car))                                   (push (list newnode (kh_count newframe)) (kh_specific newframe)))                                 (if (not (member newframe (kh_general newnode) :key #'car))                                   (push (list newframe (kh_count newframe)) (kh_general newnode)))                                 (list newnode newframe t))                               (let* ((last_recurs (recurs_generalize_cycle (kh_last m)))                                      (last (car last_recurs))                                      (last_frame (cadr last_recurs))                                      (frame_continue (member (kh_cycle_frame m)                                                              (if (typep (kh_cycle_frame (kh_last m)) 'kh_cyclic_pattern)                                                                (cons (kh_next (kh_cycle_frame (kh_last m)))                                                                      (kh_children (kh_cycle_frame (kh_last m))))                                                                (kh_children (kh_cycle_frame (kh_last m))))))                                      (frame_incompleted (and (caddr last_recurs) frame_continue))                                      (newframe (and last_frame                                                     (if (not frame_incompleted)                                                       (kh_cycle_frame m)                                                       (or (car (member (kh_description m) (kh_children last_frame) :key #'kh_description :test #'kh_equal))                                                           (let ((newf (make-instance 'kh_pattern                                                                         :kh_address (incf *kh_node_counter*)                                                                         :kh_last last_frame                                                                         :kh_description (kh_description m))))                                                             (or (member newf (kh_acyclic_children last_frame))                                                                 (push newf (kh_acyclic_children last_frame)))                                                             (if nodebug                                                               (progn                                                                 (print 'kh_generalize_general_frame)                                                                 (kh_print newf)))                                                             (kh_interlink_node newf last_frame (kh_description m) t)                                                             newf)))))                                      (newnode (make-instance 'kh_cyclic_pattern                                                 :kh_address counter                                                 :kh_pos (1+ (kh_pos last))                                                 :kh_last last                                                 :kh_description (kh_description m)                                                 :kh_cycle_frame (or newframe (kh_cycle_frame m)))))                                 ;(kh_print last_frame)                                 ;(loop for i in (kh_acyclic_children last_frame)                                 ;      do (kh_print i))                                 ;(print "..")                                 ;(kh_print newframe)                                 ;(kh_print newnode)                                 (if (not frame_continue)                                   (progn                                     (push newnode (kh_cyclic_children last_frame))                                     (setf (kh_acyclic_last newnode) last_frame)                                     ;(print 'm)                                     (kh_interlink_node newnode last_frame (kh_description m) t))                                   (progn                                     ;(print 'n)                                     (if frame_incompleted                                       (kh_interlink_node newframe last_frame (kh_description m) t)                                       (kh_interlink_node newnode last (kh_description m) nil))))                                 (setf (kh_next last) newnode)                                 (if (not (member newnode (kh_specific newframe) :key #'car))                                   (push (list newnode (kh_count newframe)) (kh_specific newframe)))                                 (if (not (member newframe (kh_general newnode) :key #'car))                                   (push (list newframe (kh_count newframe)) (kh_general newnode)))                                 (push m (kh_specific_cycle newnode))                                 (push newnode (kh_general_cycle m))                                 (list newnode newframe frame_incompleted)))))                    (recurs_generalize_cycle (kh_last next))))          (node3 (car resurs)))     (if (not (kh_cyclic_children (cadr resurs)))       (progn         (push node0 (kh_cyclic_children (cadr resurs)))         (setf (kh_acyclic_last node0) (cadr resurs))))     (setf (kh_last node0) node3)     (setf (kh_next node3) node0)     (labels ((recurs_finish_interlink_node (n)                (or (not (member (kh_cycle_frame (kh_next n)) (kh_children (kh_cycle_frame n))))                    (progn                      ;(print 'o)                      (kh_interlink_node (kh_next n) n (kh_description (kh_next n)) nil)                      (kh_interlink_cycle (kh_next n))                      (recurs_finish_interlink_node (kh_next n))))))       (if (caddr resurs)         (progn           ;(print 'p)           (kh_interlink_node node0 (kh_cycle_frame node3) description nil)           (kh_interlink_cycle node0)           (recurs_finish_interlink_node node0))         (recurs_finish_interlink_node node3)))     (push next (kh_specific_cycle node0))     (push node0 (kh_general_cycle next))     (kh_check_link node0)     (and (equal *kh_print* 'all)          (kh_print node0))     node0))(defun kh_remove_duplicate (list)   (loop for l on list         when (not (member (car l) (cdr l)))         collect (car l)))(defun kh_collect_general_cycle (n)   (print "recurs_collect_general_cycle")   (kh_print n)   (kh_remove_duplicate (cons n (loop for s in (kh_general_cycle n)                                      append (kh_collect_general_cycle s)))))(defun kh_collect_specific_cycle (n)   (and (= (kh_address (car *kh_notes*)) 0)        (print "recurs_collect_specific_cycle")        (kh_print n))   (kh_remove_duplicate (cons n (loop for s in (kh_specific_cycle n)                                      append (kh_collect_specific_cycle s)))))(defun kh_new_cycle (occurrence description node relation)      (db_print "kh_new_cycle" 0 (kh_address (kh_to relation)))   ;(print "kh_new_cycle")   (let ((oldocc (kh_generalize occurrence node))                (new_element (kh_to relation))                (debug 0))            (and (= (kh_address new_element) debug)                 (progn                    (print "kh_new_cycle?")                   (kh_print occurrence)                   (kh_print description)                   (kh_print node)                   ))            (and oldocc                 (let ((cyclic_node (if (kh_cyclicp (car node))                                      (car node)                                      (loop for c in (kh_children (car node))                                            when (and ;(kh_equal_or_specific description (kh_description c))                                                  (kh_cyclicp c))                                            return (kh_last c)))))                   (and cyclic_node                        (not (and (= (kh_address new_element) debug)                                  (not (kh_print cyclic_node))                                  (kh_print (kh_cycle_frame cyclic_node))                                  ))                        (let* ((res (labels ((recurs_find_old_description (o n d c)                                               (and (= (kh_address new_element) debug)                                                    (progn                                                       (print "recurs_find_old_description")                                                      (kh_print o)                                                      (kh_print n)                                                      (kh_print d)))                                               (and o ;pour éviter temporairement les problèmes de cycles imbriqués                                                    (if (equal n (car node))                                                      (progn                                                        (and (= (kh_address new_element) debug)                                                             (progn                                                                (print ">>")                                                               (kh_print o)))                                                        (list o d))                                                      (if (or (not (kh_last (kh_last n)))                                                              (and (not c)                                                                   (kh_cyclicp n)                                                                   (setq c t)                                                                   (kh_equal_or_specific d (kh_description (kh_next n)))))                                                        (loop for oc in (kh_upto (kh_param o))                                                              when (progn                                                                     (and (= (kh_address new_element) debug)                                                                          (progn                                                                             (print "recurs_find_old_description2")                                                                            (kh_print oc)                                                                            (kh_print (car node))))                                                                     (kh_equal_or_specific oc (car node)))                                                              return (list (kh_generalize oc node) d))                                                        (let ((generalized (kh_generalize o (list n (kh_count n)))))                                                          (and generalized                                                               (recurs_find_old_description (kh_last o) (kh_last n) (kh_description (kh_relation generalized)) c))))))))                                      (recurs_find_old_description (kh_last oldocc) (kh_last (car node)) (kh_description (kh_relation oldocc)) (kh_cyclicp (car node)))))                               (old_occ (car res))                               (next_desc (cadr res))                               (intersect1 (and old_occ                                                (kh_intersect_description description next_desc))))                          (and (= (kh_address new_element) debug)                               (progn                                 (kh_print old_occ)                                 (kh_print next_desc)                                 (kh_print intersect1)))                          (and intersect1                               (not (kh_nil intersect1 nil))                               (or (not (= (kh_address new_element) debug))                                   (progn                                      (print "kh_new_cycle??")                                     (kh_print occurrence)                                     (kh_print description)                                     (kh_print (car node))                                     (kh_print cyclic_node)                                     (not (kh_print old_occ))                                     (not (kh_print intersect1))                                     t))                               (or ;(not (print "kh_new_cycle"))                                ;(kh_print occurrence)                                ;(kh_print (car node))                                ;(kh_print intersect1)                                ;(and (= (kh_address new_element) debug)                                ;     (not (print "ok? ?")))                                ;(kh_equal_or_specific (kh_description (kh_next cyclic_node)) intersect1)                                    (and (= (kh_address new_element) debug)                                     (not (print "cycle plus specifique ?")))                                (loop for s in (kh_specific_cycle cyclic_node) ;euh, pourquoi les plus spécifiques ?                                      thereis (and ;(print ">>")                                               ;(not (kh_print s))                                               (kh_superposed_period occurrence (kh_description relation) s)                                               (kh_equal_or_specific (kh_description (kh_next s)) intersect1)                                               (progn ;(print "remember_cycle")                                                 ;(kh_print s)                                                 ;(print 's)                                                 (kh_remember relation occurrence (kh_next s) node)                                                 t                                                 )))                                (and (= (kh_address new_element) debug)                                     (not (print "cycle plus specifique 2 ?")))                                (loop for o in (kh_upto (kh_param occurrence))                                      thereis (and ;(print ">")                                               ;(not (kh_print o))                                               ;(not (kh_print occurrence))                                               (typep (kh_node o) 'kh_cyclic_pattern)                                               (kh_superposed_suffix_period o occurrence cyclic_node)                                               (loop for next in (kh_next o)                                                     thereis (and ;(print ">>>>>")                                                              ;(not (kh_print next))                                                              ;(not (kh_print intersect1))                                                              (kh_equal_or_specific (kh_description next) intersect1)))))                                (and (= (kh_address new_element) debug)                                     (not (print "cycle plus general ?")))                                (loop for o in (kh_upto (kh_param occurrence))                                      thereis (progn                                                (or (not (= (kh_address new_element) debug))                                                    (progn                                                       (print "?")                                                      (not (kh_print o))))                                                (loop for g in (kh_all_general o)                                                      thereis (progn                                                                (or (not (= (kh_address new_element) debug))                                                                    (progn                                                                       (print "??")                                                                      (not (kh_print g))))                                                                (loop for c in (kh_children (car g))                                                                      thereis (and (kh_cyclicp c)                                                                                   (or (not (= (kh_address new_element) debug))                                                                                       (progn                                                                                          (print "???")                                                                                         (not (kh_print c))))                                                                                   (kh_equal_length_period2 cyclic_node c)                                                                                   (kh_equal_or_specific (kh_description c) intersect1)                                                                                   (kh_equal_or_specific (kh_description relation) (kh_description c))                                                                                   (progn                                                                                     (or (not (= (kh_address new_element) debug))                                                                                         (progn                                                                                            (print "remember_cycle!")                                                                                           (kh_print o)                                                                                           (kh_print g)                                                                                           (kh_print c)))                                                                                     ;(print 'g)                                                                                     (kh_remember relation o c g)                                                                                     t                                                                                     )))))))                                (and (= (kh_address new_element) debug)                                      (not (print "ok")))                                (and (= (kh_address new_element) debug)                                     (progn                                        (not (print "kh_new_cycle!"))                                       (kh_print occurrence)                                       (kh_print node)                                       (kh_print intersect1)                                       (kh_print old_occ)                                       (kh_print cyclic_node)                                      nil))                                (let* ((oldnodes (kh_most_specific (loop for g in (kh_collect_general_cycle cyclic_node)                                                                         when (and                                                                               ;(print ">")                                                                               ;(not (kh_print g))                                                                               (kh_superposed_period occurrence (kh_description relation) g)                                                                               (kh_superposed_period old_occ next_desc g)                                                                               ;(not (kh_print g))                                                                               )                                                                         collect g)))                                       (old_node (if (cdr oldnodes)                                                   (print "plusieurs specifiques !!")                                                   (car oldnodes)))                                       (newnode (if old_node                                                  (kh_change_cycle intersect1 old_node 'specify (kh_new old_occ))                                                  (kh_change_cycle intersect1 cyclic_node nil (kh_new old_occ)))))                                  (and (= (kh_address new_element) debug)                                       (progn                                          (print ">>>>")                                         (kh_print old_node)                                         (kh_print newnode)                                         (kh_print (kh_last newnode))                                         (kh_print old_occ)))                                  (labels ((recurs_new_cycle (o n)                                             ;(print "recurs_new_cycle")                                             ;(kh_print o)                                             (if (equal (kh_param o) (kh_param old_occ))                                               old_occ                                               (let* ((last (recurs_new_cycle (kh_last o) (kh_last n)))                                                      (newoccurrence (kh_instantiate_node last (kh_relation o) n nil nil)))                                                 (if (= (kh_address new_element) debug)                                                   (progn                                                     (print ">>>")                                                     (kh_print o)                                                     (kh_print n)                                                     (kh_print newoccurrence)                                                     ))                                                 (loop for relation in (kh_from (kh_param o))                                                       do (kh_memorize newoccurrence relation (list n)))                                                 (kh_interlink newoccurrence)                                                 newoccurrence))))                                    (kh_interlink (kh_instantiate_node (recurs_new_cycle oldocc (kh_last newnode))                                                                       relation                                                                       newnode                                                                       t (and old_node 'specify))))                                  ;(print "new_cycle")                                  ;(kh_print newnode)                                  ;(kh_print (kh_cycle_frame newnode))                                  ;(print (kh_children newnode))                                  t))                               (kh_equal intersect1 description))))))))(defun kh_last_cycle (occ)   ;(print "kh_last_cycle")   ;(kh_print occ)   (labels ((recurs_last_cycle (o)              (and o                   (if (or (equal (kh_node o) (kh_node occ))                           (member (kh_node o) (kh_specific_cycle (kh_node occ)))                           )                     o                     (recurs_last_cycle (kh_last o))))))     (recurs_last_cycle (kh_last occ))))(defun kh_generalize (occurrence node)   (setq condition (and nil                        (car node)                        occurrence                        (equal (kh_address occurrence) 56)                        (equal (kh_address (car node)) 12)                        ;(kh_cyclicp (car node))                        ;(= (kh_address (car *kh_notes*)) 11)                        ))   (if condition     (progn       (print "kh_generalize")       (kh_print occurrence)          (kh_print node)))   (and occurrence        (if (cadr node)          (and (not (equal (car node) *kh_root*))               (labels ((recurs_cumul (o i d r)                          (and condition                               (progn                                 (print "recurs_cumul")                                 (not (kh_print o))                                 (print i)                                 (not (kh_print d))                                 (not (kh_print r))                                 ))                          (if (or (not *kh_graph*)                                  (= i 1))                            (and (kh_equal_or_specific d r)                                 o)                            (and (kh_last o)                                 (recurs_cumul (kh_last o)                                               (1- i)                                               (kh_cumul d (kh_inter_description o)) r))))                        (recurs_specify (o n l i)                          (and n                               (progn (and condition                                           (progn                                             (print "recurs_specify")                                             (not (kh_print o))                                             (not (kh_print n))                                             (print l)                                             (print i)                                             ))                                      ;(not (kh_print (kh_description n)))))                                      (or (let ((pick (loop for oc in (kh_upto (kh_param o))                                                            when (and (equal (kh_node oc) n)                                                                      (kh_equal_or_specific o oc))                                                            collect (progn                                                                      (or (not condition)                                                                          (not (print "pick"))                                                                          (kh_print oc))                                                                      oc))))                                            (and pick                                                 (car (kh_most_general pick))))                                          (let* ((last (and ;(cadr l) REGLER LE PROBLEME DE GENERALISATION DES CYCLES                                                        (kh_last o)                                                        (not (equal (kh_last n) *kh_root*))                                                        (kh_to (kh_param o))                                                        (kh_equal_or_specific (kh_note_description o) (kh_note_description n))                                                        (let ((last_occ (recurs_cumul (kh_last o)                                                                                      (or (not *kh_graph*)                                                                              (if (cadr l)                                                                                              (- (cadr l) (car l))                                                                                              1))                                                                                      (kh_inter_description o)                                                                                      (kh_inter_description n))))                                                          (and last_occ                                                               (recurs_specify last_occ (kh_last n) (cdr l) (1+ i))))))                                                 (check (and last                                                             (kh_check_emergence last (kh_description n))                                                             (progn ;(print "emergence in generalize !")                                                               ;(kh_print occurrence)                                                                  ;(kh_print node)                                                               ;(kh_print last)                                                               ;(kh_print (kh_last o))                                                               (throw 'emergence nil))))                                                 (newnode (if last                                                             (and (if (member n (append (kh_children (kh_node last))                                                                                       (and (kh_cyclicp (kh_node last))                                                                                            (list (kh_next (kh_node last))))))                                                                   n                                                                   (or (and (kh_cyclicp n)                                                                            (loop for frame in (list (kh_cycle_frame n))                                                                                  when (progn                                                                                         (and condition                                                                                              (progn(print "frame :")                                                                                                    (kh_print n)                                                                                                    (kh_print frame)                                                                                                    (kh_print (kh_last frame))                                                                                                    (kh_print (kh_node last))))                                                                                         (equal (kh_last frame) (kh_node last)))                                                                                  return frame))                                                                       (car (member (kh_description n) (kh_children (kh_node last)) :key #'kh_description :test #'kh_equal))                                                                       (let ((newnode2 (make-instance 'kh_pattern                                                                                         :kh_address (incf *kh_node_counter*)                                                                                         :kh_last (kh_node last)                                                                                         :kh_description (kh_description n))))                                                                         (and (or condition nodebug)                                                                              (progn                                                                                (print 'kh_generalize)                                                                                (kh_print occurrence)                                                                                   (kh_print node)                                                                                (kh_print newnode2)))                                                                         (push newnode2 (kh_acyclic_children (kh_node last)))                                                                         (kh_interlink_node newnode2 (kh_node last) (kh_description n) t)                                                                         newnode2                                                                         ))))                                                            (if (member n (kh_children *kh_root*))                                                              n                                                              (or (car (member (kh_note_description n) (kh_children *kh_root*) :key #'kh_note_description :test #'kh_equal))                                                                  (let ((newnode2 (make-instance 'kh_pattern                                                                                    :kh_address (incf *kh_node_counter*)                                                                                    :kh_last *kh_root*                                                                                    :kh_description (kh_note_description n))))                                                                    (if t ;nodebug                                                                      (progn                                                                        (print 'kh_generalize2)                                                                        (kh_print newnode2)))                                                                    (push newnode2 (kh_acyclic_children *kh_root*))                                                                    (kh_interlink_node newnode2 *kh_root* (kh_note_description n) t)                                                                    newnode2                                                                    )))                                                            ))                                                 (newoccurrence (and newnode                                                                     (kh_instantiate_node last (kh_relation o) newnode nil nil))))                                            (and newoccurrence                                                 (progn (kh_interlink newoccurrence)                                                        (and condition                                                             (progn (print "kh_generalize..")                                                               (kh_print occurrence)                                                                  (kh_print node)                                                                                                      ;(print ">>recurs_specify>")                                                               ;(not (kh_print o))                                                               ;(not (kh_print n))                                                               (kh_print newoccurrence)))                                                        newoccurrence))))))))                 (catch 'emergence (recurs_specify occurrence (car node) (reverse (cadr node)) 0))))          occurrence)))(defun kh_generalize_whole_cycle (frame)   ;(print "kh_generalize_whole_cycle")   ;(kh_print frame)   (let* ((node0 nil)          (counter (incf *kh_cyclic_counter*))          (node1 (labels ((recurs_generalize_whole_cycle (f)                            ;(print "recurs_generalize_whole_cycle")                            ;(kh_print f)                            (if (not (kh_last (kh_last f)))                              (let* ((newnode (make-instance 'kh_cyclic_pattern                                                :kh_address counter                                                :kh_pos 0                                                :kh_last nil                                                :kh_description (kh_description f)                                                :kh_cycle_frame f)))                                (setq node0 newnode)                                ;(print 'q)                                (kh_interlink_node newnode frame (kh_description f) t)                                (push newnode (kh_cyclic_children frame))                                (setf (kh_acyclic_last newnode) frame)                                (if (not (member newnode (kh_specific f) :key #'car))                                  (push (list newnode (kh_count f)) (kh_specific f)))                                (if (not (member f (kh_general newnode) :key #'car))                                  (push (list f (kh_count f)) (kh_general newnode)))                                newnode)                              (let* ((last (recurs_generalize_whole_cycle (kh_last f)))                                     (newnode (make-instance 'kh_cyclic_pattern                                                :kh_address counter                                                :kh_pos (1+ (kh_pos last))                                                :kh_last last                                                :kh_description (kh_description f)                                                :kh_cycle_frame f)))                                ;(print 'r)                                (kh_interlink_node newnode last (kh_description f) nil)                                (setf (kh_next last) newnode)                                (if (not (member newnode (kh_specific f) :key #'car))                                  (push (list newnode (kh_count f)) (kh_specific f)))                                (if (not (member f (kh_general newnode) :key #'car))                                  (push (list f (kh_count f)) (kh_general newnode)))                                newnode))))                   (recurs_generalize_whole_cycle frame))))     (setf (kh_last node0) node1)     (setf (kh_next node1) node0)     ;(print 's)     (kh_interlink_node node0 node1 (kh_description node0) nil)     (kh_interlink_cycle node0)     (and (equal *kh_print* 'all)          (kh_print node1))     node1))(defun kh_link (newoccurrence specific)   ;(print "kh_link")   ;(kh_print newoccurrence)   ;(loop for i in specific   ;      do (kh_print i))   ;(print "....")   (loop for s in specific         when (not (member newoccurrence (kh_general s)))         do (progn (push newoccurrence (kh_general s))                   (push s (kh_specific newoccurrence)))))(defun kh_interlink (newoccurrence)   ;(print "kh_interlink")   ;(kh_print newoccurrence)   (let ((specific (kh_new_most_specific newoccurrence))         (general (kh_new_most_general newoccurrence)))     ;(loop for i in specific     ;      do (kh_print i))     ;(print "....")     ;(loop for i in general     ;      do (kh_print i))     ;(print "....")     (kh_link newoccurrence specific)     (loop for g in general           when (not (member newoccurrence (kh_specific g)))           do (progn (push newoccurrence (kh_specific g))                     (push g (kh_general newoccurrence))))     (loop for s in specific           do (loop for g in general                    do (progn (setf (kh_specific g) (delete s (kh_specific g)))                              (setf (kh_general s) (delete g (kh_general s))))))))(defun kh_interlink_node (newnode oldnode description extending)   (let ((condition (and (typep newnode 'kh_cyclic_pattern)                     (= (kh_address newnode) 0))))     (and condition          (print "kh_interlink_node")          (not (kh_print newnode))          (not (kh_print oldnode))          (print extending)          (kh_print description))     (and (not (kh_cyclicp newnode))          (loop for s in (kh_new_most_specific_node oldnode description newnode) ;verifier pour extending = nil                when (and ;(print ">s?")                      ;(not (kh_print s))                      (not (equal (car s) newnode))                      (or (not extending)                          (kh_equal_or_specific (car s) newnode)))                do (progn (and condition                               (print ">s")                               (kh_print s))                          (if (and (not (member newnode (kh_general (car s)) :key #'car))                                   (not (member (car s) (kh_general newnode) :key #'car)) ;garde-fous à supprimer par la suite                                   )                            (push (list newnode (cadr s)) (kh_general (car s))))                          (if (and (not (member (car s) (kh_specific newnode) :key #'car))                                   (not (member newnode (kh_specific (car s)) :key #'car)) ;garde-fous à supprimer par la suite                                   )                            (push (list (car s) (cadr s)) (kh_specific newnode))))))     (loop for g in (kh_new_most_general_node oldnode description newnode) ;verifier pour extending = nil           when (and ;(print ">g?")                 ;(not (kh_print (car g)))                 (not (equal (car g) newnode))                 (or (not extending)                     (kh_equal_or_specific newnode (car g))))           do (progn (and condition                          (print ">g")                          (kh_print g))                     (if (and (not (member newnode (kh_specific (car g)) :key #'car))                              (not (member (car g) (kh_specific newnode) :key #'car)) ;garde-fous à supprimer par la suite                              )                       (push (list newnode (cadr g)) (kh_specific (car g))))                     (if (and (not (member (car g) (kh_general newnode) :key #'car))                              (not (member newnode (kh_general (car g)) :key #'car)) ;garde-fous à supprimer par la suite                              )                       (push (list (car g) (cadr g)) (kh_general newnode)))))     (and condition          (progn            (not (kh_print newnode))            (print "ok")            (not (kh_print (kh_specific newnode)))            (kh_print (kh_general newnode))))     ))(defun kh_interlink_cycle (node)   (and nil        (print "kh_interlink_cycle")        (not (kh_print node)))   (labels ((recurs_interlink_cycle (n)              ;(print "recurs_interlink_cycle")              ;(kh_print n)              (progn                (loop for s in (kh_specific n)                      when (and ;(print ">s")                            ;(not (kh_print (car s)))                            (not (equal (car s) n))                            (kh_equal_length_period2 (car s) n)                            ;(not (member (car s) (kh_specific_cycle n)))                            ;(not (member n (kh_general_cycle (car s))))                            )                      do (progn                           (push (car s) (kh_specific_cycle n))                           (push n (kh_general_cycle (car s)))))                (loop for g in (kh_general n)                      when (and ;(print ">g")                            ;(not (kh_print (car g)))                            (not (equal (car g) n))                            (typep (car g) 'kh_cyclic_pattern)                            (kh_equal_length_period2 (car g) n)                            ;(not (member (car g) (kh_general_cycle n)))                            ;(not (member  n (kh_specific_cycle (car g))))                            )                      do (progn (and nil                                     (= (kh_address node) 13)                                     (print ">g")                                     (kh_print (car g)))                                (push (car g) (kh_general_cycle n))                                (push n (kh_specific_cycle (car g)))))                (and (= (kh_address node) 0)                     (not (kh_print node))                     (print "ok"))                (or (equal (kh_last n) node)                    (recurs_interlink_cycle (kh_last n))))))     (recurs_interlink_cycle node)))(defun kh_instantiate_node (from to node print new)   ;(print "kh_instantiate_node")   ;(and from (kh_print from))   ;(kh_print (kh_to to))   ;(kh_print node)   (or (car (member node (kh_upto (kh_to to)) :key #'kh_node))    (if (typep (kh_to to) 'kh_pattern)      (let ((res (make-instance 'kh_occurrence                   :kh_address (incf *kh_occurrence_counter*)                   :kh_node node                   :kh_last from                   :kh_relation to)))        (push res (kh_upto (kh_to to)))        (if from          (push res (kh_next from)))        res)      (let ((res (make-instance 'kh_occurrence                   :kh_address (incf *kh_occurrence_counter*)                   :kh_node node                   :kh_last from                   :kh_relation to                   :kh_new new                   )))        (push res (kh_upto (kh_to to)))        #|(labels ((recurs_instantiate_node (n)           (print "nn")           (kh_print n)           (print (kh_upto n))           (push res (kh_upto n))           (print (kh_upto n))           (if (and (not (typep n 'kh_note))                            (kh_last n))                     (recurs_instantiate_node (kh_last n)))))          (recurs_instantiate_node (kh_from to)))|#        (and from             (push res (kh_next from)))        (push res (kh_occurrence node))        (and print             (equal *kh_print* 'all)             (kh_print res))        ;(kh_print node)        (and from             (kh_instantiate res))        ;(kh_print res)        res))))(defmethod kh_list ((occurrence kh_occurrence))   (labels ((recurs_list (o)              (append               (and (kh_last o)                    (recurs_list (kh_last o)))               (list (kh_param o)))))     (recurs_list occurrence)))(defmethod kh_enumerate ((occurrence kh_occurrence))   (and (equal (kh_address occurrence) 0)        (print "kh_enumerate")        (kh_print occurrence)        )   (labels ((recurs_enumerate (o d c)              (and (equal (kh_address occurrence) 0)                   (progn                     (print "recurs_enumerate")                     (kh_print o)                     (kh_print d)                     (print c)))              (append               (and (kh_last o)                    (or c                        (not (kh_cyclicp o))                        (not (setq c t))                        (not (kh_equal_or_specific d (kh_description (kh_next (kh_node o))))))                    (recurs_enumerate (kh_last o) (kh_description o) c))               (progn                 ;(kh_print o)                 (list o)))))     (recurs_enumerate occurrence nil (kh_cyclicp occurrence))))(defmethod kh_enumerate_pattern ((occurrence kh_occurrence) (pattern list))   (let ((condebug (and (= (kh_address (car *kh_notes*)) 0)                        (equal (kh_address occurrence) 102)                        (equal (kh_address (car pattern)) 12))))     (and condebug          (progn (print "kh_enumerate_pattern")                 (kh_print occurrence)                 (kh_print pattern)))     (if (cadr pattern)       (if (kh_cyclicp (car pattern))         (kh_enumerate (kh_generalize occurrence pattern))         (labels ((recurs_last_cumul (o i)                    (and condebug                         (progn (print "recurs_last_cumul")                                (kh_print o)                                (print i)))                    (if (or (= i 0)                            (kh_cyclicp (car pattern)))                      o                      (recurs_last_cumul (kh_last o) (1- i))))                  (recurs_enumerate_pattern (o p l d co cp i)                    (and condebug                         (progn (print "recurs_enumerate_pattern")                                (kh_print o)                                (kh_print p)                                (print l)                                (print i)                                (kh_print d)                                (print co)                                (print cp)))                    (and (> i -1)                         (if (or (not *kh_graph*)                                 (= i (car l))                                 (kh_cyclicp (car pattern)))                           (append                            (and (not (equal (kh_last p) *kh_root*))                                 (kh_equal_or_specific (kh_description o) (kh_description p))                                 (or cp                                     (not (kh_cyclicp p))                                     (not (setq cp t))                                     (not (kh_equal_or_specific d (kh_description (kh_next p)))))                                 (if (or (not o)                                         (and nil                                              (not co)                                              (kh_cyclicp o)                                              (setq co t)                                              (kh_equal_or_specific d (kh_description (kh_next (kh_node o))))                                              (print "too_short")                                              (progn (not (kh_print occurrence))                                                     (kh_print (car pattern))                                                     t)                                              ))                                   (and (not (typep (kh_last p) 'kh_cyclic_pattern))                                        (throw 'too_short nil))                                   (recurs_enumerate_pattern (kh_last o);(recurs_last_cumul o (- (cadr l) i))                                                             (kh_last p) (cdr l) (kh_description o) co cp (1- i))))                            (progn                              ;(print ">>")                              ;(kh_print o)                              (and o                                   (list o))))                           (recurs_enumerate_pattern (kh_last o) p l d co cp (1- i))                           ))))           (catch 'too_short (recurs_enumerate_pattern occurrence (car pattern) (cadr pattern) nil (kh_cyclicp occurrence) (kh_cyclicp (car pattern)) (caadr pattern)))))       (kh_enumerate occurrence))))(defmethod kh_enumerate ((pattern kh_pattern))   ;(print "kh_enumerate")   ;(print pattern)   (labels ((recurs_enumerate (n l)              ;(print ">")              ;(print n)              (append               (and (kh_last n)                    (not (member n l))                    (recurs_enumerate (kh_last n) (cons n l)))               (list n))))     (recurs_enumerate pattern nil)))(defun kh_intersect (list1 list2)   (loop for elem in list1         when (member elem list2 :test #'equal)         append (list elem)))(defmethod! kh_print ((note kh_note))   (terpri)   (format t "Note #~D : ~20,1T Time = ~D ~40,1T Pitch = ~D ~60,1T Degree = ~D ~80,1T Duration = ~D ~100,1T Interpitch = ~D ~120,1T Metric = ~D" (kh_address note) (kh_time note) (kh_pitch note)           (kh_degree note) (kh_duration note) (kh_interpitch note) (kh_metric note)))(defmethod! kh_print ((node kh_pattern))   (and *kh_print*        (progn          (terpri)          (if (kh_cyclicp node)            (format t "Pattern c#~D p#~D f#~D: ~20,1T" (kh_address node) (kh_pos node) (kh_address (kh_cycle_frame node)))              (format t "Pattern #~D : ~20,1T" (kh_address node)))          (let* ((enumerate1 (kh_enumerate node))                 (enumerate (if (kh_cyclicp (car enumerate1))                              enumerate1                              (cdr enumerate1))))            (format t "Interpitch = ~D ~40,1T Interdegree = ~D ~60,1T interonset = ~D ~80,1T pitch = ~D ~100,1T metric = ~D" ; ~80,1T Occurrence = "                    (loop for i in (cdr enumerate)                          collect (let ((interpitch (kh_interpitch (kh_description i))))                                    (and interpitch                                                                           (append (if (equal (kh_sign interpitch) #'kh_ascending)                                                   (list '+)                                                   (if (equal (kh_sign interpitch) #'kh_descending)                                                     (list '-)))                                                 (and (kh_number interpitch)                                                      (list (kh_number interpitch)))))))                    (loop for i in (cdr enumerate)                          collect (let ((interdegree (kh_interdegree (kh_description i))))                                    (and interdegree                                                                           (append (if (equal (kh_sign interdegree) #'kh_ascending)                                                   (list '+)                                                   (if (equal (kh_sign interdegree) #'kh_descending)                                                     (list '-)))                                                 (and (kh_number interdegree)                                                      (list (kh_number interdegree)))))))                    (loop for i in (cdr enumerate)                          collect (kh_interonset i))                    (loop for i in (cdr (kh_enumerate node))                          collect (kh_pitch i))                    (loop for i in (cdr (kh_enumerate node))                          collect (kh_metric i))))          #|          (loop for occurrence in (kh_occurrence node)                do (labels ((recurs_print (o)                              (format t "(")                              (loop for note in (kh_list o)                                    do (if (typep note 'kh_note)                                         (format t "n#~D" (kh_address note))                                         (recurs_print note)))                              (format t ")")))                     (recurs_print occurrence)))          |#          (and (kh_children node)               (progn                 (format t " Children = (")                 (loop for child in (kh_children node)                       do (kh_print_address child))                 (format t " )")))          (and (kh_general node)               (progn (format t " General =")                      (loop for general in (kh_general node)                            do (progn                                 (kh_print_address (car general))                                 (format t "~D" (cadr general))))))          ;#|          (and (kh_specific node)               (progn (format t " Specific =")                      (loop for specific in (kh_specific node)                            do (progn                                 (kh_print_address (car specific))                                 (format t "~D" (cadr specific))                                 (loop for occurrence in (kh_occurrence (car specific))                                       do (labels ((recurs_print2 (o)                                                     (format t "(")                                                     (loop for note in (kh_list o)                                                           do (if (typep note 'kh_note)                                                                (format t "n#~D" (kh_address note))                                                                (recurs_print2 note)))                                                     (format t ")")))                                            (recurs_print2 occurrence)))))))          (and (typep node 'kh_cyclic_pattern)               (progn                 (and (kh_general_cycle node)                      (progn (format t " General_cycle =")                             (loop for general in (kh_general_cycle node)                                   do (kh_print_address general))))                 (and (kh_specific_cycle node)                      (progn (format t " Specific_cycle =")                             (loop for general in (kh_specific_cycle node)                                   do (kh_print_address general))))))          ;|#          )))(defmethod! kh_print_address ((node kh_pattern))   (format t " N#~D" (kh_address node)))(defmethod! kh_print_address ((node kh_cyclic_pattern))   (format t " c#~D p#~D" (kh_address node) (kh_pos node)))(defmethod! kh_print ((occurrence kh_occurrence))   (and *kh_print*        (progn          (terpri)          (format t "Occurrence #~D : ~20,1T" (kh_address occurrence))          (kh_print_address (kh_node occurrence))          (format t "~30,1T")          (labels ((recurs (o)                     (format t "(")                     (loop for note in (kh_list o)                           do (if (typep note 'kh_note)                                (format t "n#~D" (kh_address note))                                (if (typep note 'kh_pattern)                                  (format t "nd~D" (kh_address note))                                  (recurs note))))                     (format t ")")))            (recurs occurrence))          (format t "   Interpitch = ~D Interdegree = ~D interonset = ~D pitch = ~D metric = ~D ~80,1T"                  (loop for i in (cdr (kh_enumerate occurrence))                        collect (let ((interpitch (kh_interpitch (kh_description i))))                                  (and interpitch                                       (append (if (equal (kh_sign interpitch) #'kh_ascending)                                                 (list '+)                                                 (if (equal (kh_sign interpitch) #'kh_descending)                                                   (list '-)))                                               (and (kh_number interpitch)                                                    (list (kh_number interpitch)))))))                  (loop for i in (cdr (kh_enumerate occurrence))                        collect (let ((interdegree (kh_interdegree (kh_description i))))                                  (and interdegree                                       (append (if (equal (kh_sign interdegree) #'kh_ascending)                                                 (list '+)                                                 (if (equal (kh_sign interdegree) #'kh_descending)                                                   (list '-)))                                               (and (kh_number interdegree)                                                    (list (kh_number interdegree)))))))                  (loop for i in (cdr (kh_enumerate occurrence))                        collect (kh_interonset (kh_description i)))                  (loop for i in (kh_enumerate occurrence)                        collect (kh_pitch (kh_description i)))                  (loop for i in (kh_enumerate occurrence)                        collect (kh_metric (kh_description i)))                  )          )))(defmethod! kh_print ((description kh_description))   (and *kh_print*        (progn          (terpri)          (format t "   Interpitch = ~D Interdegree = ~D interonset = ~D pitch = ~D metric = ~D"                  (let ((interpitch (kh_interpitch description)))                    (and interpitch                         (append (if (equal (kh_sign interpitch) #'kh_ascending)                                   (list '+)                                   (if (equal (kh_sign interpitch) #'kh_descending)                                     (list '-)))                                 (and (kh_number interpitch)                                      (list (kh_number interpitch))))))                  (let ((interdegree (kh_interdegree description)))                    (and interdegree                         (append (if (equal (kh_sign interdegree) #'kh_ascending)                                   (list '+)                                   (if (equal (kh_sign interdegree) #'kh_descending)                                     (list '-)))                                 (and (kh_number interdegree)                                      (list (kh_number interdegree))))))                  (kh_interonset description)                  (kh_pitch description)                  (kh_metric description)))))(defmethod! kh_print ((interoccurrence kh_syntagmatic_relation))   (and *kh_print*        (progn          (terpri)          (format t "InterOccurrence : NotesLeft = (")          (loop for note in (kh_list (kh_from interoccurrence))                do (if (typep note 'kh_note)                     (format t "n#~D" (kh_address note))                     (progn                       (format t "(")                       (loop for noto in (kh_list note)                             do (format t "n#~D" (kh_address noto)))                       (format t ")"))))          (format t ")  NotesRight = (")          (loop for note in (kh_list (kh_to interoccurrence))                do (if (typep note 'kh_note)                     (format t "n#~D" (kh_address note))                     (progn                       (format t "(")                       (loop for noto in (kh_list note)                             do (format t "n#~D" (kh_address noto)))                       (format t ")"))))          (format t ")"))))(defmethod! kh_print ((l list))   (mapcar #'kh_print l))(defmethod! kh_print ((n number))   (print n))(defmethod! kh_print ((n t))   (print nil))(defmethod! kh_display ((order t) (criterion t) (min_depth t) (min_depth_occ t))   :initvals '(t 'most_relevant 3 3)   :indoc '("chronological order (t) or criterion order (nil)"            "a selecting criterion ('longest, 'most_frequent, 'most_relevant, 'first_discovered)"            "min depth"            "min depth occ")   :icon 128    :numouts 1   :doc  "Lists the occurrences of the n best pattern classes in a definite order.inputs:order: pattern classes are ordered either chronologically (t) or in a decreasing values of the selecting criterion.criterion: choose either the longest patterns ('longest), most frequent ones ('most_frequent), most relevant ones ('most_relevant)where relevance is the product of frequency and length, or select the first discovered patterns ('first_discovered).output:a list of n lists of the occurrences of the n most pertinent abstract patterns."   :menuins ((0 (("chronological order" 't)                 ("criterion order" 'nil)))             (1 (("longest" 'longest)                 ("most frequent" 'most_frequent)                 ("most relevant" 'most_relevant)                 ("first discovered" 'first_discovered))))   (labels ((criterion (list_occ)              (case criterion                (longest (loop for i in list_occ                               maximize (length (kh_list (car i)))))                (most_frequent (length list_occ))                (most_relevant (* (loop for i in list_occ                                        maximize (length (kh_list (car i))))                                  (length list_occ)))                (first_discovered (- (cadr (sort (loop for occ in list_occ                                                       collect (kh_time (kh_param (car occ))))                                                 #'<)))))))     (let* ((table (loop for list_occ in (kh_list_occ min_depth min_depth_occ)                         with table = (make-hash-table)                         do (progn                              (setf (gethash (criterion (cadr list_occ)) table)                                    (cons list_occ (gethash (criterion (cadr list_occ)) table))))                         finally return table))            (key_list (sort (loop for key being the hash-key of table                                  collect key)                            #'>))            (result (loop for i being each hash-key of table using (hash-value value)                          append (progn                                   ;(print ">")                                   (loop for j in value                                         collect (kh_generate_occurrences (car j) (cadr j) min_depth_occ))))))       (loop for chord-seq in (cons (let ((list_res (sort (copy-list *kh_notes*) #'< :key #'kh_time)))                                      (list (make-instance 'chord-seq                                              :lmidic (mapcar #'(lambda (x) (* 100 (kh_chroma x))) list_res)                                              :lonset (mapcar #'(lambda (x) (kh_time x)) list_res)                                              :ldur (mapcar #'(lambda (x) (kh_duration x)) list_res)                                              :lchan 0                                              :lvel 100                                              :legato 0)                                            *kh_root*))                                    (if order                                      (sort (copy-list result) #'< :key #'(lambda (x) (car (sort (lonset (car x)) #'<))))                                      result))             for i from 0             collect (progn                       (terpri)                       (prin1 i)                       (kh_print (cadr chord-seq))                       (car chord-seq))))))(defmethod! kh_display_text ()   :initvals nil   :indoc nil   :icon 128    :numouts 1   :doc  "Lists the pattern classes."   (let ((internal_list nil)         (external_list nil))        (labels ((recurs (n b)                ;(print "recurs")                ;(kh_print n)                (or (member n internal_list)                    (progn                      (push n internal_list)                      (and (or (not (kh_children n))                               (cdr (kh_children n))                               (> (length (kh_occurrence n)) (length (kh_occurrence (car (kh_children n))))))                           b                           (push n external_list))                      (loop for c in (kh_children n)                            do (recurs c t))                      (and (typep n 'kh_cyclic_pattern)                           (kh_next n)                           (recurs (kh_next n) nil))))))       (loop for r in *kh_root*             do (recurs r t)))     (loop for n in (sort external_list #'> :key #'kh_level)           do (progn                (kh_print n)                ;(print (kh_children n))                ))))(defun kh_list_occ (min_depth min_depth_occ)   ;(print "kh_list_occ")   ;(print min_depth)   (let (;(processed_last nil)         (processed_children nil)         (processed_cycles nil)         (processed_specific nil)         (processed_notes nil)         (processed nil)         )     (labels ((find_occurrences (m)                (and m                     (not (member m processed))                     (push m processed)                     (progn                       (and nil                            (typep m 'kh_cyclic_pattern)                            (print "find_occurrences")                            (kh_print m))                       t)                     (not (setf processed_cycles nil))                     (append (loop for g in (if (typep m 'kh_cyclic_pattern)                                              (recurs_specific_cycle m)                                              (list m))                                   append (progn (or (not (= (kh_address m) -1))                                                     (not (print ">"))                                                     (kh_print g))                                                 (setf processed_specific nil)                                                 (loop for i in (append (kh_occurrence g) (recurs_specific_pattern g m)) ; nil))                                                       when (and (or (not (typep m 'kh_cyclic_pattern))                                                                     (not (= (kh_address m) 0))                                                                     (not (print ">>"))                                                                     (not (kh_print i)))                                                                 (not (member (kh_param i) processed_notes))                                                                 (or (typep g 'kh_cyclic_pattern)                                                                     (>= (kh_level i) min_depth_occ))                                                                 (push (kh_param i) processed_notes))                                                       collect (list i                                                                     (if (typep m 'kh_cyclic_pattern)                                                                       (+ (kh_pos m) (kh_level m))                                                                       (kh_level m))))))                             (and (kh_last m)                                  (or (kh_cyclicp m)                                      (not (kh_cyclicp (kh_last m))))                                  (find_occurrences (kh_last m)))                             (and (typep m 'kh_cyclic_pattern)                                  (find_occurrences (kh_acyclic_last m)))                             )))              (recurs_specific_pattern (m n); debug)                (and (not (member m processed_specific))                     (progn ;(print "recurs_specific_pattern")                       ;(kh_print m)                       ;(kh_print n)                       (push m processed_specific)                       ;(let ((problem (loop for s in (kh_specific m)                       ;                     thereis (loop for ss in (kh_specific (car s))                       ;                                   thereis (equal ss m)))))                       ;  (and ;nil                       ;   problem                       ;   (print "redundant cycles !")                       ;   (not (kh_print m)))                       (loop for s in (kh_specific m)                             append (append (mapcan #'(lambda (x)                                                        (let ((generalized (kh_generalize x (list n (cadr s)))))                                                          (and generalized                                                               (list generalized))))                                                    (kh_occurrence (car s))) ;Présence de doublons mais c'est pas grave..                                            ;(and (not debug)                                                                                 (recurs_specific_pattern (car s) n)))))) ; problem))))))))              (recurs_specific_cycle (m)                ;(print "recurs_specific_cycle")                ;(kh_print m)                (and (not (member m processed_cycles))                     (push m processed_cycles)                     (cons m                           (append                            (loop for g in (kh_specific_cycle m)                                  append (recurs_specific_cycle g))                            ;(loop for g in (kh_general_cycle m)                            ;      append (recurs_specific_cycle g))                                                    ))))              (recurs_children (n b)                ;(print "recurs_children")                ;(kh_print n)                (and (not (member n processed_children))                     (push n processed_children)                     ;(print "recurs_children")                     ;(not (kh_print n))                     ;(print (length (kh_children n)))                     (append (and b                                  (not (kh_children n))                                  (or (typep n 'kh_cyclic_pattern)                                      (>= (kh_level n) min_depth))                                  ;(print "ok")                                  ;(not (kh_print n))                                  (not (setf processed_notes nil))                                  (let ((occurrences (sort (find_occurrences n)                                                           #'>                                                           :key #'(lambda (x) (kh_time (first (kh_list (car x))))))))                                    (and occurrences                                         (list (list n occurrences)))))                             (loop for i in (kh_children n)                                   append (recurs_children i t))                             (and (typep n 'kh_cyclic_pattern)                                  (kh_next n)                                  (recurs_children (kh_next n) nil))))))       (loop for r in (list *kh_root*)             append (recurs_children r t)))))(defun kh_generate_occurrences (node list_occurrences min_depth_occ)   ;(print "kh_generate_occurrences")   ;(kh_print node)   ;(kh_print list_occurrences)   (let ((list_notes nil))     (labels ((recurs_generate_occurrences (o b n)                ;(print "recurs_generate_occurrences")                ;(print b)                ;(setf *kh_print* nil)                ;(kh_print o)                ;(print n)                (and (not (member (kh_param o) list_notes :key #'car))                     (push (list (kh_param o) (max n 0))                           list_notes)                     (kh_last o)                     ;(or (kh_cyclicp o)                     ;    (not (kh_cyclicp (kh_last o))))                     (recurs_generate_occurrences (kh_last o)                                                  b                                                  (if (or (not (typep (kh_node o) 'kh_cyclic_pattern))                                                          ;(not b)                                                          (> n 0))                                                    (1- n)                                                    ;n                                                    (kh_level (kh_node o)))))))       (loop for element in (reverse list_occurrences)             when (or                    (progn                     ;(print ">>>")                     ;(kh_print (car element))                     ;(print (cadr element))                     nil)                   (typep (kh_node (car element)) 'kh_cyclic_pattern)                   (>= (kh_level (car element)) min_depth_occ))             do (recurs_generate_occurrences (car element) (typep (kh_node (car element)) 'kh_cyclic_pattern)                                             (cadr element)))       (let ((list_res (sort list_notes #'< :key #'(lambda (x) (kh_time (car x))))))         (list (make-instance 'chord-seq                 :lmidic (mapcar #'(lambda (x) (* 100 (kh_chroma (car x)))) list_res)                 :lonset (mapcar #'(lambda (x) (kh_time (car x))) list_res)                 :ldur (mapcar #'(lambda (x) (kh_duration (car x))) list_res)                 :lchan (mapcar #'cadr list_res)                 :lvel 100                 :legato 0)               node)))))(defmethod! kh_pitch_spelling ((midi list) (tonic t) &optional (replace nil))   :initvals '(nil nil nil)   :indoc '("a MIDI sequence" "tonal reference (expressed as a MIDI pitch)")   :icon 128    :numouts 1   :doc  "Adds to the MIDI sequence an extra scale degree parameter computed relatively to the tonal referenceinputs:midi: a MIDI sequencetonic: a tonal reference (expressed as a MIDI pitch)output:the pitch-spelled MIDI sequence"   (loop for channel in midi         collect (loop for note in channel                       collect (let ((pitch_spelling (+ (case (mod (- (car note) tonic) 12)                                                          (0 0)                                                          (1 1)                                                          (2 1)                                                          (3 2)                                                          (3.25 2)                                                          (4 2)                                                          (5 3)                                                          (6 3)                                                          (7 4)                                                          (8 5)                                                          (9 5)                                                          (10 6)                                                          (11 6)                                                          (12 0))                                                        (* 7 (floor (/ (- (car note) tonic) 12))))))                                 (if replace                                   (cons pitch_spelling (cdr note))                                   (append note (list pitch_spelling)))))))(defmethod! kh_pitch_spelling ((midifile Midifile) (tonic t) &optional (replace nil))   (kh_pitch_spelling (mf-info midifile) tonic replace))(defmethod! kh_add_metric ((midi list) (tempo t) &optional (replace nil))   :initvals '(nil nil nil)   :indoc '("a MIDI sequence" "tempo (expressed as a pulse duration)")   :icon 128    :numouts 1   :doc  "Adds to the MIDI sequence an extra metric parameter computed relatively to the tempo referenceinputs:midi: a MIDI sequencetonic: a tempo reference (expressed as a pulse duration)output:the metric MIDI sequence"   (loop for channel in midi         collect (loop for note in channel                       collect (let ((metric (/ (mod (cadr note) tempo) tempo)))                                 (if replace                                   (cons metric (cdr note))                                   (append note (list metric)))))))(defmethod! kh_add_metric ((midifile Midifile) (tempo t) &optional (replace nil))   (kh_add_metric (mf-info midifile) tempo replace))(defmethod! kh_remove_unspelled ((midi list))   :initvals '(nil)   :indoc '("a MIDI sequence")   :icon 128    :numouts 1   :doc  "Remove all the pitches of the notes of the MIDI sequence.inputs:midi: a MIDI sequenceoutput:the resulting MIDI sequence"   (loop for channel in midi         collect (loop for note in channel                       collect (rplaca note nil))))(defmethod! kh_remove_unspelled ((midifile Midifile))   (kh_remove_unspelled (mf-info midifile)))(defmethod! kh_interonset_flat ((midi list))   :initvals '(nil)   :indoc '("a MIDI sequence")   :icon 128    :numouts 1   (loop for channel in midi         collect (loop for note in channel                       for n from 1                       collect (cons (car note) (cons n (cddr note))))))(defmethod! kh_interonset_incorporate ((midi list) (interonset list))   :initvals '(nil)   :indoc '("a MIDI sequence" "a interonsetic sequence")   :icon 128    :numouts 1   (loop for channel in midi         collect (loop for note in channel                       for r in (cons 0 interonset)                       with sum = 0                       collect (progn                                 (setq sum (+ sum r))                                 (cons (car note) (cons sum (cddr note)))))))(defmethod! kh_interonset_quantify ((midi list) (tolerance number))   :initvals '(nil 0)   :indoc '("a MIDI sequence" "a tolerance in ms")   :icon 128    :numouts 1   (loop for channel in midi         collect (loop for note in channel                       with date = 0                       with previous = 0                       collect (let ((interonset (* (round (/ (- (cadr note) previous) tolerance)) tolerance)))                                 (setq previous (cadr note))                                 (incf date interonset)                                 (cons (car note)                                       (cons date                                             (cons interonset                                                   (cdddr note))))))))(defmethod! kh_upper_voice ((midi list))   :initvals '(nil nil)   :indoc '("a MIDI sequence")   :icon 128    :numouts 1   :doc  "Takes the highest note of each chord of the MIDI sequence, and all the isolated notes.inputs:midi: a MIDI sequenceoutput:the pitch-spelled MIDI sequence"   (loop for channel in midi         collect (labels ((parcours (l)                            (and l                                                             (upper_voice l nil (second (car l)))))                          (upper_voice (l upper onset)                            (if l                              (if (< (- (second (car l)) onset) 30)                                (upper_voice (cdr l)                                             (if (or (not upper)                                                     (> (first (car l)) (first upper)))                                               (car l)                                               upper)                                             onset)                                (cons upper (parcours l)))                              (and upper (list upper)))))                   (parcours channel))))(defmethod! kh_upper_voice ((midifile Midifile))   (kh_upper_voice (mf-info midifile)))(defmethod! kh_lower_voice ((midi list))   :initvals '(nil nil)   :indoc '("a MIDI sequence")   :icon 128    :numouts 1   :doc  "Takes the highest note of each chord of the MIDI sequence, and all the isolated notes.inputs:midi: a MIDI sequenceoutput:the pitch-spelled MIDI sequence"   (loop for channel in midi         collect (labels ((parcours (l)                            (and l                                                             (upper_voice l nil (second (car l)))))                          (upper_voice (l upper onset)                            (if l                              (if (< (- (second (car l)) onset) 30)                                (upper_voice (cdr l)                                             (if (or (not upper)                                                     (< (first (car l)) (first upper)))                                               (car l)                                               upper)                                             onset)                                (cons upper (parcours l)))                              (and upper (list upper)))))                   (parcours channel))))(defmethod! kh_lower_voice ((midifile Midifile))   (kh_lower_voice (mf-info midifile)))(defmethod! kh_remove_short ((midi list) (threshold t))   :initvals '(nil 120)   :indoc '("a MIDI sequence (optionnally extended with pitch spelling informations)"            "duration threshold")   :icon 128    :numouts 1   :doc  "Removes short notes of the MIDI sequence. (More precisely: the first MIDI channel.)"   (list (loop for event in (car midi)               when (> (third event) threshold)               collect event)))(defmethod! kh_remove_short ((midifile MidiFile) (threshold t))   (kh_remove_short (mf-info midifile) threshold))(defmethod! kh_remove_repet ((midi list))   :initvals '(nil)   :indoc '("a MIDI sequence (optionnally extended with pitch spelling informations)")   :icon 128    :numouts 1   :doc  "Removes repeated notes of the MIDI sequence. (More precisely: the first MIDI channel.)"   (list (loop for event in (car midi)               for last in (cons nil (car midi))               when (not (and last                              (equal (first event) (first last))))               collect event)))(defmethod! kh_remove_repet ((midifile MidiFile))   (kh_remove_repet (mf-info midifile)))(defmethod! kh_mark_ornement ((midi list))   :initvals '(nil)   :indoc '("a MIDI sequence (optionnally extended with pitch spelling informations)")   :icon 128    :numouts 1   :doc  "Removes ornementations in the MIDI sequence. (More precisely: the first MIDI channel.)"   ;(print (mapcar #'first (car midi)))   (labels ((recurs_mark_ornement (events i buffer result)              ;(print (car events))              (if events                (let ((candidate (loop for j on (reverse buffer)                                       with res = nil                                       when (and (= (fifth (car j)) 0)                                                 (= (fifth (car events)) 0)                                                 (= (first (car events)) (first (car j))))                                       do (setq res j)                                       finally return res)))                  ;(print candidate)                  (if (and candidate                           (or (not (member-if #'(lambda (x) (= (fifth x) 0))                                               (cdr events)))                               (let ((interonset (- (second (car (member-if #'(lambda (x) (= (fifth x) 0))                                                                            (cdr events))))                                                    (second (car events)))))                                 (loop for n on (append (cdr candidate) (list (car events)))                                       always (or (not (= (fifth (car n)) 0))                                                  (not (member-if #'(lambda (x) (= (fifth x) 0))                                                                  (cdr n)))                                                  (> interonset (- (second (car (member-if #'(lambda (x) (= (fifth x) 0))                                                                                           (cdr n))))                                                                   (second (car n))))))))                           ;(print "ornement !")                           ;(print events)                           ;(print candidate)                           ;(print (mapcar #'first (firstn (reverse buffer)                           ;                               (+ (- i (length candidate)) 1))))                           ;(print (mapcar #'first (append (last (reverse buffer) (- (length candidate) 1))                           ;                               (list (car events)))))                           ;(print (mapcar #'first (cdr events)))                           )                    (let ((res (append (firstn (reverse buffer)                                               (+ (- i (length candidate)) 1))                                       (loop for i in (append (last (reverse buffer) (- (length candidate) 1))                                                              (list (car events)))                                             with change = nil                                             collect (append (first-n i 4)                                                             (list (if change                                                                     (1+ (fifth i))                                                                     (or (and (= (fifth i) 0)                                                                              (setq change t)                                                                              1)                                                                         0)))                                                             (last i)))                                       (cdr events))))                      (recurs_mark_ornement res 0 nil res))                    (recurs_mark_ornement (cdr events) (1+ i) (cons (car events) buffer) result)))                (list (reverse buffer)))))     (recurs_mark_ornement (loop for i in (car midi)                                 collect (append (first-n i 4) (list 0) (last i)))                           0 nil nil)))(defmethod! kh_mark_ornement ((midifile MidiFile))   (kh_mark_ornement (mf-info midifile)))(defmethod! kh_dispatch_mark ((midi list))   :indoc '("a MIDI sequence (optionnally extended with pitch spelling informations)")   :icon 128    :numouts 1   :doc  ""   (loop for i from (apply #'max (mapcar #'fifth (car midi))) downto 0         collect (loop for j in (car midi)                       when (<= (fifth j) i)                       collect j)))(defmethod! kh_dispatch_mark ((midifile MidiFile))   (kh_dispatch_mark (mf-info midifile)))(defmethod! kh_remove_ornement ((midi list) &optional (progression nil))   :initvals '(nil nil)   :indoc '("a MIDI sequence (optionnally extended with pitch spelling informations)")   :icon 128    :numouts 1   :doc  "Removes ornementations in the MIDI sequence. (More precisely: the first MIDI channel.)"   (print (mapcar #'first (car midi)))   (labels ((recurs_remove_ornement (events i buffer result)              (if events                (let ((candidate (loop for j on (reverse buffer)                                       with res = nil                                       when (= (first (car events)) (first (car j)))                                       do (setq res j)                                       finally return res)))                  ;(print (car events))                  (if (and candidate                           (or (not (cdr events))                               (let ((interonset (- (second (cadr events)) (second (car events)))))                                 (loop for n on (append (cdr candidate) (list (car events)))                                       always (or (not (cdr n))                                                  (> interonset (- (second (cadr n)) (second (car n))))))))                           (print "ornement !")                           (print events)                           (print candidate)                           (print (mapcar #'first (firstn (reverse buffer)                                                          (+ (- i (length candidate)) 1))))                           (print (mapcar #'first (cdr events)))                           )                    (recurs_remove_ornement (append (firstn (reverse buffer)                                                            (+ (- i (length candidate)) 1))                                                    (cdr events))                                            0 nil                                            (cons (append (firstn (reverse buffer)                                                                  (+ (- i (length candidate)) 1))                                                          (cdr events))                                                  result))                    (recurs_remove_ornement (cdr events) (1+ i) (cons (car events) buffer) result)))                (if progression                  (cons (car midi) (reverse result))                  (list (reverse buffer))))))     (recurs_remove_ornement (car midi) 0 nil nil)))(defmethod! kh_remove_ornement ((midifile MidiFile) &optional (progression nil))   (kh_remove_ornement (mf-info midifile) nil))(defmethod! kh_pitch_stat ((midi list) &optional (duration nil))   :initvals '(nil nil)   :indoc '("a MIDI sequence (optionnally extended with pitch spelling informations)")   :icon 128    :numouts 1   :doc  "Removes ornementations in the MIDI sequence. (More precisely: the first MIDI channel.)"   (loop for pitch from 0 to 11         collect (loop for events on (car midi)                       with count = 0                       with total = 0                       do (progn                            (and (= (mod (first (car events)) 12) pitch)                                 (setf count (+ count (if duration                                                        (if (cadr events)                                                          (- (second (cadr events)) (second (car events)))                                                          10)                                                        1))))                            (setf total (+ total (if duration                                                   (if (cadr events)                                                     (- (second (cadr events)) (second (car events)))                                                     10)                                                   1))))                       finally return (* (/ count total) 100.0))))(defmethod! kh_pitch_stat ((midifile MidiFile) &optional (duration nil))   (kh_pitch_stat (mf-info midifile) duration))(defun db_print (param level note)   (if (equal note 0)     (print param))   )(defun db_kh_print (param level note)   (if (equal note 0)     (progn       (setf *kh_print* 'all)       (kh_print param)))   )(defun bab_pitch (list)   (loop for bar in list         append (loop for beat in (cdr bar)                      append (loop for event in (cdr beat)                                   append (loop for note in (cdr event)                                                collect (if (listp note)                                                          (cadr note)                                                          note))))))(defun bab_channel (list)   (loop for bar in list         append (loop for beat in (cdr bar)                      append (loop for event in (cdr beat)                                   collect (let ((res (cadr event)))                                             (if (listp res)                                               (car res)                                               1))))))(defun bab_onset (list bars)   (loop for bar in list         append (loop for beat in (cdr bar)                      append (loop for event in (cdr beat)                                   collect (bab_position (car event) (car beat) (car bar) bars)))))(defun bab_position (tick beat bar bars)   ;(print "bab_position")   ;(print tick)   ;(print beat)   ;(print bar)   (+ (1- tick)      (* 4 (1- beat))      (* 4 (nth (1- bar) bars))))(defun bab_fusion (list listbar &optional develop)   (let* ((nb_channels (1- (length list)))          (zeros (loop for voice in list                       collect 0)))     (labels ((recurs_fusion (onset bars beats events bufbar bufbeat currentbar currentbeat)                ;(print "recurs_fusion")                ;(print onset)                ;(print currentbar)                ;(print currentbeat)                ;(print bars)                ;(print beats)                ;(print events)                (let* ((newbars bars)                       (newbeats beats)                       (newevents events)                       (newbufbar bufbar)                       (newbufbeat bufbeat)                       (newbufevent nil)                       (allbar t)                       (allbeat t)                       (newcurrentbar currentbar)                       (newcurrentbeat currentbeat))                  (loop for c from 0                        for bar_pos in bars                        for beat_pos in beats                        for event_pos in events                        for voice in list                        do (let* ((bar (and bar_pos (nth bar_pos voice)))                                  (beat (nth beat_pos (cdr bar)))                                  (event (nth event_pos (cdr beat)))                                  (position (and bar (bab_position (car event) (car beat) (car bar) listbar))))                             ;(print bar)                             ;(print beat)                             ;(print event)                             ;(print currentbar)                             ;(print currentbeat)                             ;(print position)                             (if (and position                                      (= position onset))                               (let ((newevent_pos (nth c newevents))                                     (newbeat_pos (nth c newbeats))                                     (newbar_pos (nth c newbars)))                                 (if newbufevent                                   (rplacd newbufevent (cons (list (1+ c) (cadr event)) (cdr newbufevent)))                                   (setf newbufevent (list (car event) (list (1+ c) (cadr event)))))                                 (setf newevent_pos                                       (if (nth (1+ event_pos) (cdr beat))                                         (1+ newevent_pos)                                         (progn                                           (setf newbeat_pos                                                 (if (nth (1+ beat_pos) (cdr bar))                                                   (1+ newbeat_pos)                                                   (progn                                                     (setf newbar_pos                                                           (and (nth bar_pos (cdr voice))                                                                (1+ newbar_pos)))                                                     0)))                                           0)))                                 (let* ((newbar (and newbar_pos (nth newbar_pos voice)))                                        (newbeat (nth newbeat_pos (cdr bar)))                                        (newevent (nth newevent_pos (cdr beat)))                                        (newposition (and newbar (bab_position (car newevent) (car newbeat) (car newbar) listbar))))                                   (setf allbeat (and allbeat                                                      (or (not newposition)                                                          (>= newposition (bab_position 1 (1+ (car beat)) (car bar) listbar)))))                                   (setf allbar (and allbar                                                     (or (not newposition)                                                         (>=  newposition (bab_position 1 1 (1+ (car bar)) listbar))))))                                 (setf newevents (append (first-n newevents c)                                                         (list newevent_pos)                                                         (and (< c nb_channels)                                                              (last newevents (- nb_channels c)))))                                 (setf newbeats (append (first-n newbeats c)                                                        (list newbeat_pos)                                                        (and (< c nb_channels)                                                             (last newbeats (- nb_channels c)))))                                 (setf newbars (append (first-n newbars c)                                                       (list newbar_pos)                                                       (and (< c nb_channels)                                                            (last newbars (- nb_channels c)))))                                 ;(print newevents)                                 ;(print newbeats)                                 ;(print newbars)                                 ;(print "newbufevent")                                 ;(print newbufevent)                                 )                               (progn                                 (setf allbeat (and allbeat                                                    (or (not position)                                                        (not currentbar)                                                        (>= position (bab_position 1 (1+ currentbeat) currentbar listbar)))))                                 (setf allbar (and allbar                                                   (or (not position)                                                       (not currentbar)                                                       (>= position (bab_position 1 1 (1+ currentbar) listbar)))))))))                  (and newbufevent                       (setf newbufbeat (append (or newbufbeat                                                    (list currentbeat))                                                (list newbufevent)))                       ;(print "newbufbeat")                       ;(print newbufbeat)                       )                  (and allbeat                       currentbar                       newbufbeat                       (progn (setf newbufbar (append (or newbufbar                                                          (list currentbar))                                                      (list newbufbeat)))                              ;(print "newbufbar")                              ;(print newbufbar)                              (progn (setf newbufbeat nil)                                     (setf newcurrentbeat (loop for voice in list                                                                for newbeat_pos in newbeats                                                                for bar_pos in bars                                                                for newbar_pos in newbars                                                                when (and bar_pos                                                                          newbar_pos                                                                          (= bar_pos newbar_pos))                                                                minimize (car (nth newbeat_pos (cdr (nth bar_pos voice)))))))))                  (append (if develop                            (and newbufevent                                 (if (and allbar                                          currentbar)                                   (progn (setf newcurrentbar (loop for voice in list                                                                    for newbar_pos in newbars                                                                    when newbar_pos                                                                    minimize (car (nth newbar_pos voice))))                                          (setf newcurrentbeat (loop for voice in list                                                                     for newbeat_pos in newbeats                                                                     for newbar_pos in newbars                                                                     when newbar_pos                                                                     minimize (car (nth newbeat_pos (cdr (nth newbar_pos voice))))))                                          (setf newbufbar nil)                                          t)                                   t)                                 (loop for i in (cdr newbufevent)                                       append (list (list develop (list currentbar (list currentbeat (list (car newbufevent) i)))))))                            (and allbar                                 currentbar                                 (setf newcurrentbar (loop for voice in list                                                           for newbar_pos in newbars                                                           when newbar_pos                                                           minimize (car (nth newbar_pos voice))))                                 (setf newcurrentbeat (loop for voice in list                                                            for newbeat_pos in newbeats                                                            for newbar_pos in newbars                                                            when newbar_pos                                                            minimize (car (nth newbeat_pos (cdr (nth newbar_pos voice))))))                                      (append (and newbufbar (list newbufbar)) (setf newbufbar nil))))                          (and (loop for n in newbars                                     thereis n)                               (recurs_fusion (1+ onset) newbars newbeats newevents newbufbar newbufbeat newcurrentbar newcurrentbeat))))))       (recurs_fusion 0 zeros zeros zeros nil nil 1 1))))