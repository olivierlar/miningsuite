#summary Overall description of the architecture of PatMinr module.

= _PatMinr_ module =

 Overall description of the architecture

== Classes ==

`pat.occurrence`: PatOccurrence

to be continuedâ€¦


== How it works ==

=== `mus.minr`:`Process_notes`===

Each note:

 * `mus.minr`:`Process` note


=== `mus.minr`:`Process` note ===

Each previous note syntagmatically leading to the note:

 * `pat.syntagm` previous note -> current note

 * Create a `pat.occurrence` of the elementary note pattern and call `memorize` Ã¸ -> syntagm (cf. below)

=== `pat.syntagm` previous -> current ===

Constructs a syntagmatic relation between previous and current note.

Tries to extend all the pattern occurrences (including cycles) ending at the previous note with the new syntagmatic relation, with the following order:

 * First, extends cycles: Call `pat.occurrence.memorize` cycle -> syntagm with generalization.

 * Then, extends the set of pattern occurrences ordered in decreasing order of specificity, by first calling `pat.occurrence.memorize` occurrence -> syntagm on each of them without generalization, and then calling once again `pat.occurrence.memorize` occurrence -> syntagm on each of them but this time with generalization.

=== `pat.occurrence.memorize` occurrence -> syntagm, with or without generalisation ===

 * Calls `pat.pattern.remember` (occurrence pattern, occurrence -> syntagm) to check if occurrence -> syntagm can be recognised as a known pattern extension of the occurrence pattern.
 * Also calls `pat.pattern.remember` for all patterns more specific than the occurrence pattern.
 * If there is generalisation, also calls `pat.pattern.remember` for all patterns more general than the occurrence pattern.
 * Calls `pat.memostruct.learn` (occurrence pattern memory, occurrence -> syntagm) to check if  occurrence -> syntagm can be identified with a previously memorised extension, leading to a new pattern extension.
 * If there is generalisation, also calls `pat.memostruct.learn` for all patterns more general than the occurrence pattern.

=== `pat.pattern.remember` pattern, occurrence -> syntagm ===

description under construction...

=== `pat.memory.learn` pattern, memory, occurrence -> syntagm ===

Behavior different if the parametric memory is of type `pat.memostruct` (a combination of elementary memories) or of type `pat.memoparam` (an elementary memory).

 === `pat.memostruct.learn` pattern, memory, occurrence -> syntagm ===

 * Accumulates the memory related to the more specific patterns.
 * Calls `pat.memory.combine` to process the learning phase along the different parametric dimension and combine them together.

 === `pat.memoparam.learn` pattern, memory, occurrence -> syntagm ===

 * Calls `pat.memoparam.find`to detects the syntagm description in the memory hash-table.
 * If a previously memorised occurrence is identified as of same parametric description, calls `pat.pattern.link` for the current pattern, the pattern detection result, and occurrence -> syntagm.
 * Else if...
 * Calls recursively `pat.memoparam.learn` for the interval field, and for the more general parametric fields.

=== `pat.memory.combine` pattern, parametric memory, occurrence -> syntagm ===

 * Calls recursively `learn` to the subfields of the parametric memory, and accumulates the pattern detection results.
 * If the combined pattern detection result is not empty, and is not implied by an already existing pattern extension, calls `pat.pattern.link` for the current pattern, the pattern detection result, and occurrence -> syntagm.