#summary Overall description of the architecture of PatMinr module.

= _PatMinr_ module =

 Overall description of the architecture

== Classes ==

`pat.occurrence`: PatOccurrence

to be continuedâ€¦


== How it works ==

=== `mus.minr`:`Process_notes`===

Each note:

 {{{
mus.minr:Process note
}}}

=== `mus.minr`:`Process` note ===

Each previous note syntagmatically leading to the note:

 * Constructs a syntagmatic relation:
{{{
syntagm = pat.syntagm previous_note -> note
}}}

 * Creates a `pat.occurrence` Ã¸ of the elementary note pattern and call:
{{{
pat.occurrence.memorize Ã¸ -> syntagm
}}}

=== `pat.syntagm` previous_note -> note ===

Constructs a syntagmatic relation between previous and current note.

Tries to extend all the pattern occurrences (including cycles) ending at the previous note, in decreasing order of specificity, with the new syntagmatic relation by calling:
{{{
pat.occurrence.memorize occurrence -> syntagm, general_patterns
}}}
where `general_patterns` is the set of patterns more general than the occurrence's pattern. To avoid duplicating the set of general patterns, for each occurrence, only general patterns that are not more general than the patterns of the more general occurrences are included.

=== `pat.occurrence.memorize` occurrence -> syntagm, general_patterns ===

 * Calls `pat.pattern.remember` (occurrence pattern, occurrence -> syntagm) to check if occurrence -> syntagm can be recognised as a known pattern extension of the occurrence pattern.
 * Also calls `pat.pattern.remember` for all patterns more specific than the occurrence pattern.
 * If there is generalisation, also calls `pat.pattern.remember` for all patterns more general than the occurrence pattern.
 * Calls `pat.memostruct.learn` (occurrence pattern memory, occurrence -> syntagm) to check if  occurrence -> syntagm can be identified with a previously memorised extension, leading to a new pattern extension.
 * If there is generalisation, also calls `pat.memostruct.learn` for all patterns more general than the occurrence pattern.

=== `pat.pattern.remember` pattern, occurrence -> syntagm ===

description under construction...

=== `pat.memory.learn` pattern, memory, occurrence -> syntagm ===

Behavior different if the parametric memory is of type `pat.memostruct` (a combination of elementary memories) or of type `pat.memoparam` (an elementary memory).

 === `pat.memostruct.learn` pattern, memory, occurrence -> syntagm ===

 * Accumulates the memory related to the more specific patterns.
 * Calls `pat.memory.combine` to process the learning phase along the different parametric dimension and combine them together.

 === `pat.memoparam.learn` pattern, memory, occurrence -> syntagm ===

 * Calls `pat.memoparam.find`to detects the syntagm description in the memory hash-table.
 * If a previously memorised occurrence is identified as of same parametric description, calls `pat.pattern.link` for the current pattern, the pattern detection result, and occurrence -> syntagm.
 * Else if...
 * Calls recursively `pat.memoparam.learn` for the interval field, and for the more general parametric fields.

=== `pat.memory.combine` pattern, parametric memory, occurrence -> syntagm ===

 * Calls recursively `learn` to the subfields of the parametric memory, and accumulates the pattern detection results.
 * If the combined pattern detection result is not empty, and is not implied by an already existing pattern extension, calls `pat.pattern.link` for the current pattern, the pattern detection result, and occurrence -> syntagm.