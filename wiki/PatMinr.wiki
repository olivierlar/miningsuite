#summary Overall description of the architecture of PatMinr module.

= _PatMinr_ module =

 Overall description of the architecture

== Classes ==

`pat.occurrence`: PatOccurrence

to be continuedâ€¦


== How it works ==

=== `mus.minr`:`Process_notes`===

Each note:

 {{{
mus.minr:Process note
}}}

=== `mus.minr`:`Process` note ===

Each previous note syntagmatically leading to the note:

 * Constructs a syntagmatic relation:
{{{
syntagm = pat.syntagm previous_note -> note
}}}

 * Creates a `pat.occurrence` Ã¸ of the elementary note pattern and call:
{{{
pat.occurrence.memorize Ã¸ -> syntagm
}}}

=== `pat.syntagm` previous_note -> note ===

Constructs a syntagmatic relation between previous and current note.

Tries to extend all the pattern occurrences (including cycles) ending at the previous note, in decreasing order of specificity, with the new syntagmatic relation by calling:
{{{
pat.occurrence.memorize occurrence -> syntagm, not_specific_general_patterns
}}}
where `not_specific_general_patterns` is the set of patterns more general than the patterns of the more general occurrences. These general patterns will be already considered by more general occurrences, so don't need to be considered by the current more specific occurrence.

=== `pat.occurrence.memorize` occurrence -> syntagm, not_specific_general_patterns ===

 * Checks if occurrence -> syntagm can be recognised as a known pattern extension of the occurrence's pattern `pattern`, by calling
{{{
pat.pattern.remember pattern, occurrence -> syntagm
}}}

 * Do the same for any pattern `pattern` more specific than the occurrence pattern.

 * Do the same for any pattern `pattern` more general than the occurrence pattern that meet the following conditions:
   * It is not member of the set `not_specific_general_patterns` (which will be considered already by more general occurrences).
   * It can be applied to the current context (cf. `pat.pattern.incompatible`).
   * It is not more general than a cycle currently developing up to the occurrence's last note.

 * Check if  occurrence -> syntagm can be identified with a previously memorised extension, leading to a new pattern extension, by calling:
{{{
pat.memostruct.learn memory, occurrence -> syntagm
}}}
where `memory` is the associative memory storing the extensions of the occurrence's pattern.

 * Do the same for the associative memory `memory` related to any pattern more general than the occurrence pattern that meet the following conditions:
   * It is not member of the set `not_specific_general_patterns` (which will be considered already by more general occurrences).
   * It can be applied to the current context (cf. `pat.pattern.incompatible`).

=== `pat.pattern.remember` pattern, occurrence -> syntagm ===

description under construction...

=== `pat.memory.learn` pattern, memory, occurrence -> syntagm ===

Behavior different if the parametric memory is of type `pat.memostruct` (a combination of elementary memories) or of type `pat.memoparam` (an elementary memory).

 === `pat.memostruct.learn` pattern, memory, occurrence -> syntagm ===

 * Accumulates the memory related to the more specific patterns.
 * Calls `pat.memory.combine` to process the learning phase along the different parametric dimension and combine them together.

 === `pat.memoparam.learn` pattern, memory, occurrence -> syntagm ===

 * Calls `pat.memoparam.find`to detects the syntagm description in the memory hash-table.
 * If a previously memorised occurrence is identified as of same parametric description, calls `pat.pattern.link` for the current pattern, the pattern detection result, and occurrence -> syntagm.
 * Else if...
 * Calls recursively `pat.memoparam.learn` for the interval field, and for the more general parametric fields.

=== `pat.memory.combine` pattern, parametric memory, occurrence -> syntagm ===

 * Calls recursively `learn` to the subfields of the parametric memory, and accumulates the pattern detection results.
 * If the combined pattern detection result is not empty, and is not implied by an already existing pattern extension, calls `pat.pattern.link` for the current pattern, the pattern detection result, and occurrence -> syntagm.