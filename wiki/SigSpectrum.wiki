#summary sig.spectrum: Fourier transform

= sig.spectrum: Fourier transform =

A decomposition of the energy of a signal (be it an audio waveform, or an envelope, etc.) along frequencies can be performed using a Discrete Fourier Transform, which, for an audio signal x has for equation:<p>

  https://miningsuite.googlecode.com/svn/wiki/SigSpectrum_eq1.png

This decomposition is performed using a Fast Fourier Transform by the `sig.spectrum function by calling Matlab _fft_ function. The graph returned by the function highlights the repartition of the amplitude of the frequencies (i.e., the modulus of _Xk_ for all _k_), such as the following:<p>

https://miningsuite.googlecode.com/svn/wiki/SigSpectrum_ex1.png

We can also obtain for each frequency the actual phase position (i.e., the phase of _Xk_), which indicates the exact position of each frequency component at the instant _t = 0_. If the result of the spectrum decomposition is s, the phase spectrum is obtained by using the command:

{{{
get(s,'Phase')
}}}

<br>
== Flowchart Interconnections ==

`sig.spectrum` accepts as input data type either:

  * `sig.input` objects, where the audio waveform can be segmented (using `sig.segment`), decomposed into channels (using `sig.filterbank`), and/or decomposed into frames (using `sig.frame`);<p>
  * file name(s) or the `'Folder'` keyword;<p>
  * data in the onset detection curve category (cf. SigOnset):<p>
  *  `sig.envelope` objects, frame-decomposed or not,<p>
  * fluxes (cf. SigFlux), frame-decomposed or not;<p>
  * `sig.spectrum` frame-decomposed objects: by calling again `sig.spectrum` with the `'AlongBands'` option, Fourier transforms are computed this time on each temporal signal related to each separate frequency bin (or frequency band, cf. below).

<br>
== Frame decomposition ==
`sig.spectrum(…,'Frame',…)` performs first a frame decomposition, with by default a frame length of 50 ms and half overlapping. For the specification of other frame configuration using additional parameters, cf. the previous SigFrame vs. 'Frame' section.

<br>
== Parameters specification ==
The range of frequencies, in Hz, can be specified by the options:

  * `sig.spectrum(…,'Min',`_mi_`)` indicates the lowest frequency taken into consideration, expressed in Hz. Default value: 0 Hz.<p>
  * `sig.spectrum(…,'Max',`_ma_`)` indicates the highest frequency taken into consideration, expressed in Hz. Default value: the maximal possible frequency, corresponding to the sampling rate divided by 2.<p>
  * `sig.spectrum(…,'Window',`_w_`)` specifies the windowing method. Windows are used to avoid the problems due to the discontinuities provoked by finite signals. Indeed, an audio sequence is not infinite, and the application of the Fourier Transform requires to replace the infinite time before and after the sequence by zeroes, leading to possible discontinuities at the borders. Windows are used to counteract those discontinuities. Possible values for _w_ are either _w = 0_ (no windowing) or any windowing function proposed in the _Signal Processing Toolbox^*^_. Default value: _w_ = `'Hamming'`, the Hamming window being a particular good window for Fourier Transform.<p>
  * `sig.spectrum(…,'NormalInput')` normalizes the waveform between 0 and 1 before computing the Fourier Transform.<p>
  * `sig.spectrum(…,'Phase','No')` does not compute the related FFT phase. The FFT phase is not computed anyway whenever another option that will make the phase information irrelevant (such as `'Log','dB'`, etc.) is specified.
  ^*^ The list of possible window arguments can be found in the _window_ documentation:
{{{
help window
}}}

<br>
== Resolution specification ==

The frequency resolution of the spectrum directly depends on the size of the audio waveform: the longer the waveform, the better the frequency resolution. It is possible, however, to increase the frequency resolution of a given audio waveform by simply adding a series of zeros at the end of the sequence, which is called _zero-padding_. Besides, an optimized version of the Discrete Fourier Transform, called Fast Fourier Transform (FFT) can be performed if the length of the audio waveform (including the zero-padding) is a power of 2. For this reason, by default, a zero-padding is performed by default in order to ensure that the length of the audio waveform is a power of 2. But these operations can be tuned individually:

  * `sig.spectrum(…,'MinRes',`_mr_`)` adds a constraint related to the a minimal frequency resolution, fixed to the value _mr_ (in Hz). The audio waveform is automatically zero-padded to the lowest power of 2 ensuring the required frequency resolution.

  * `sig.spectrum(…,'MinRes',`_r_`,'OctaveRatio',`_tol_`)`: Indicates the minimal accepted resolution in terms of number of divisions of the octave. Low frequencies are ignored in order to reach the desired resolution. The corresponding required frequency resolution is equal to the difference between the first frequency bins, multiplied by the constraining multiplicative factor _tol_ (set by default to .75).

  * `sig.spectrum(…,'Res',`_r_`)` specifies the frequency resolution _r_ (in Hz) that will be secured as closely as possible, through an automated zero-padding. The length of the resulting audio waveform will not necessarily be a power of 2, therefore the FFT routine will rarely be used.

  * `sig.spectrum(…,'Length',`_l_`)` specifies the length of the audio waveform after zero-padding. If the length is not a power of 2, the FFT routine will not be used.

  * `sig.spectrum(…,'ZeroPad',`_s_`)` performs a zero-padding of s samples. If the total length is not a power of 2, the FFT routine will not be used.

  * `sig.spectrum(…,'WarningRes',`_mr_`)` indicates a required frequency resolution, in Hz, for the input signal. If the resolution does not reach that prerequisite, a warning is displayed.

Alternatively, the spectrum decomposition can be performed through a Constant Q Transform instead of a FFT, which enables to express the frequency resolution as a constant number of bins per octave:

  * `sig.spectrum(…,'ConstantQ',`_nb_`)` fixes the number of bins per octave to _nb_. Default value when the `'ConstantQ'` option is toggled on: _nb_ = 12 bins per octave.

Please note however that the Constant Q Transform is implemented as a _Matlab_ M file, whereas _Matlab's_ FFT algorithm is optimized, therefore faster.

<br>

== Post-processing options ==

  * `sig.spectrum(…,'Terhardt')` modulates the energy following (Terhardt, 1979) outer ear model. The function is mainly characterized by an attenuation in the lower and higher registers of the spectrum, and an emphasis around 2–5 KHz, where much of the speech information is carried. (Code based on Pampalk's MA toolbox). 

  * `sig.spectrum(…,'Normal')` normalizes with respect to energy: each magnitude is divided by the euclidian norm (root sum of the squared magnitude). 

  * `sig.spectrum(…,'NormalLength')` normalizes with respect to the duration (in s.) of the audio input data.

  * `sig.spectrum(…,'Power')` squares the energy: each magnitude is squared.

  * `sig.spectrum(…,'dB')` represents the spectrum energy in decibel scale. For the previous example we obtain the following spectrum:<p>

  https://miningsuite.googlecode.com/svn/wiki/SigSpectrum_ex2.png

  * `sig.spectrum(…,'dB',`_th_`)` keeps only the highest energy over a range of _th_ dB. For example if we take only the 20 most highest dB in the previous example we obtain:<p>

  https://miningsuite.googlecode.com/svn/wiki/SigSpectrum_ex3.png

  * `sig.spectrum(…,'Resonance',`_r_`)` multiplies the spectrum curve with a resonance curve that emphasizes pulsations that are more easily perceived. Two resonance curves are available:
   * _r_ = `'ToiviainenSnyder'` (Toiviainen & Snyder 2003), default choice, used for onset detection (cf. SigTempo),
   * _r_ = `'Fluctuation'` : fluctuation strength (Fastl 1982), default choice for frame-decomposed `'sig.spectrum'` objects redecomposed in 'Mel' bands (cf. SigFluctuation).<p>

  * `sig.spectrum(…,'Smooth',`_o_`)` smooths the spectrum curve using a moving average of order _o_. Default value when the option is toggled on: _o_ = 10

  * `sig.spectrum(…,'Gauss',`_o_`)` smooths the spectrum curve using a gaussian of standard deviation _o_ samples. Default value when the option is toggled on: _o_ = 10
 
  * `sig.spectrum(…,'TimeSmooth',`_o_`)` smooths each frequency channel of a spectrogram using a moving average of order _o_. Default value when the option is toggled on: _o_ = 10

<br>
== Frequency redistribution ==

  * `sig.spectrum(…,'Cents')` redistributes the frequencies along cents. Each octave is decomposed into 1200 bins equally distant in the logarithmic representation. The frequency axis is hence expressed in MIDI-cents unit: to each pitch of the equal temperament is associated the corresponding MIDI pitch standard value multiply by 100 (69*100=6900 for A4=440Hz, 70*100=7000 for B4, etc.).

  https://miningsuite.googlecode.com/svn/wiki/SigSpectrum_ex4.png

  
 It has to be noticed that this decomposition requires a frequency resolution that gets higher for lower frequencies: a cent-distribution starting from infinitely low frequency (near 0 Hz would require an infinite frequency resolution). Hence by default, the cent-decomposition is defined only for the frequency range suitable for the frequency resolution initially associated to the given spectrum representation. Two levers are available here:<p>
   * If a minimal frequency range for the spectrum representation has been set (using the `'Min'` parameter), the frequency resolution of the spectrum is automatically set in order to meet that particular requirement.<p>

  https://miningsuite.googlecode.com/svn/wiki/SigSpectrum_ex5.png
    _sig.spectrum('ragtime','Cents','Min',100)_

   * By increasing the frequency resolution of the spectrum (for instance by using the `'Res'` or `'MinRes'` parameters), the frequency range will be increased accordingly.

  * `sig.spectrum(…,'Collapsed')` collapses the cent-spectrum into one octave. In the resulting spectrum, the abscissa contains in total 1200 bins, representing the 1200 cents of one octave, and each bin contains the energy related to one position of one octave and of all the multiple of this octave.

  * `sig.spectrum(…,'Mel')` redistributes the frequencies along Mel bands. The Mel-scale of auditory pitch was established on the basis of listening experiments with simple tones (Stevens and Volkman, 1940). The Mel scale is now mainly used for the reason of its historical priority only. It is closely related to the Bark scale. It requires the _Auditory Toolbox_.

  * `sig.spectrum(…,'Bands',`_b_`)` specifies the number of band in the decomposition. By default _b_ = 40.

In our example we obtain the following:<p>

  https://miningsuite.googlecode.com/svn/wiki/SigSpectrum_ex6.png

The Mel-scale transformation requires a sufficient frequency resolution of the spectrum: as the lower bands are separated with a distance of 66 Hz, the frequency resolution should be higher than 66 Hz in order to ensure that each Mel band can be associated with at least one frequency bin of the spectrum. If the `'Mel'` option is performed in the same _sig.spectrum_ command that performs the actual FFT, then the minimal frequency resolution is implicitly ensured, by forcing the minimal frequency resolution (`'MinRes'` parameter) to be equal or below 66 Hz. If on the contrary the `'Mel'` is performed in a second step, and if the frequency resolution is worse than 66 Hz, then a warning message is displayed in the Command Window.

  * `sig.spectrum(…,'Bark')` redistributes the frequencies along critical band rates (in Bark). Measurement of the classical "critical bandwidth" typically involves loudness summation experiments (Zwicker et al., 1957). The critical band rate scale differs from Mel-scale mainly in that it uses the critical band as a natural scale unit. The code is based on the _MA_ toolbox.

  * `sig.spectrum(…,'Mask')` models masking phenomena in each band: when a certain energy appears at a given frequency, lower frequencies in the same frequency region may be unheard, following particular equations. By modeling these masking effects, the unheard periodicities are removed from the spectrum. The code is based on the _MA_ toolbox. In our example this will lead to:<p>
	
  https://miningsuite.googlecode.com/svn/wiki/SigSpectrum_ex7.png


== Harmonic spectral analysis ==

A lot of natural sounds, especially musical ones, are harmonic: each sound consists of a series of frequencies at a multiple ratio of the one of lowest frequency, called fundamental. Techniques have been developed in signal processing to reduce each harmonic series to its fundamental, in order to simplify the representation. _MiningSuite_ includes two related techniques for the attenuation of harmonics in spectral representation (Alonso et al, 2003):

  * `sig.spectrum(…,'Prod',`_m_`)` Enhances components that have harmonics located at multiples of range(s) _m_ of the signal's fundamental frequency. Computed by compressing the signal by a list of factors _m_, and by multiplying all the results with the original signal. Default value is _m_ = 1:6. Hence for this initial spectrum:

  https://miningsuite.googlecode.com/svn/wiki/SigSpectrum_ex8.png

we obtain this reduced spectrum:

  https://miningsuite.googlecode.com/svn/wiki/SigSpectrum_ex9.png

  * `sig.spectrum(…,'Sum',`_m_`)` Similar idea using addition of the multiples instead of multiplication.

<br>
== Accessible Output ==

cf. §5.2 for an explanation of the use of the `'get'` method. Specific fields:

  * `'Frequency'`: the frequency (in Hz.) associated to each bin (same as `'Pos'`),

  * `'Magnitude'`: the magnitude associated to each bin (same as `'Data'`),

  * `'Phase'`: the phase associated to each bin,

  * `'XScale'`: whether the frequency scale has been redistributed into cents – with (`'Cents(Collapsed)'`) or without (`'Cents'`) collapsing into one octave –, mels (`'Mel'`), barks (`'Bark'`), or not redistributed at all (`'Freq'`),

  * `'Power'`: whether the spectrum has been squared (1) or not (0),

  * `'Log'`: whether the spectrum is in log-scale (1) or in linear scale (0).