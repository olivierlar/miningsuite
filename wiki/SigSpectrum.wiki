#summary sig.spectrum: Fourier transform

= sig.spectrum: Fourier transform =

A decomposition of the energy of a signal (be it an audio waveform, or an envelope, etc.) along frequencies can be performed using a Discrete Fourier Transform, which, for an audio signal x has for equation:<p>

  https://miningsuite.googlecode.com/svn/wiki/SigSpectrum_eq1.png

This decomposition is performed using a Fast Fourier Transform by the `sig.spectrum function by calling Matlab _fft_ function. The graph returned by the function highlights the repartition of the amplitude of the frequencies (i.e., the modulus of _Xk_ for all _k_), such as the following:<p>

https://miningsuite.googlecode.com/svn/wiki/SigSpectrum_ex1.png

We can also obtain for each frequency the actual phase position (i.e., the phase of _Xk_), which indicates the exact position of each frequency component at the instant _t = 0_. If the result of the spectrum decomposition is s, the phase spectrum is obtained by using the command:

{{{
get(s,'Phase')
}}}

<br>
== Flowchart Interconnections ==

`sig.spectrum` accepts as input data type either:

  * `sig.input` objects, where the audio waveform can be segmented (using `sig.segment`), decomposed into channels (using `sig.filterbank`), and/or decomposed into frames (using `sig.frame`);<p>
  * file name(s) or the `'Folder'` keyword;<p>
  * data in the onset detection curve category (cf. SigOnset):<p>
  *  `sig.envelope` objects, frame-decomposed or not,<p>
  * fluxes (cf. SigFlux), frame-decomposed or not;<p>
  * `sig.spectrum` frame-decomposed objects: by calling again `sig.spectrum` with the `'AlongBands'` option, Fourier transforms are computed this time on each temporal signal related to each separate frequency bin (or frequency band, cf. below).

<br>
== Frame decomposition ==
`sig.spectrum(…,'Frame',…)` performs first a frame decomposition, with by default a frame length of 50 ms and half overlapping. For the specification of other frame configuration using additional parameters, cf. the previous SigFrame vs. 'Frame' section.

<br>
== Parameters specification ==
The range of frequencies, in Hz, can be specified by the options:

  * `sig.spectrum(…,'Min',`_mi_`)` indicates the lowest frequency taken into consideration, expressed in Hz. Default value: 0 Hz.<p>
  * `sig.spectrum(…,'Max',`_ma_`)` indicates the highest frequency taken into consideration, expressed in Hz. Default value: the maximal possible frequency, corresponding to the sampling rate divided by 2.<p>
  * `sig.spectrum(…,'Window',`_w_`)` specifies the windowing method. Windows are used to avoid the problems due to the discontinuities provoked by finite signals. Indeed, an audio sequence is not infinite, and the application of the Fourier Transform requires to replace the infinite time before and after the sequence by zeroes, leading to possible discontinuities at the borders. Windows are used to counteract those discontinuities. Possible values for _w_ are either _w = 0_ (no windowing) or any windowing function proposed in the _Signal Processing Toolbox^*^_. Default value: _w_ = `'Hamming'`, the Hamming window being a particular good window for Fourier Transform.<p>
  * `sig.spectrum(…,'NormalInput')` normalizes the waveform between 0 and 1 before computing the Fourier Transform.<p>
  * `sig.spectrum(…,'Phase','No')` does not compute the related FFT phase. The FFT phase is not computed anyway whenever another option that will make the phase information irrelevant (such as `'Log','dB'`, etc.) is specified.
  ^*^ The list of possible window arguments can be found in the _window_ documentation:
{{{
help window
}}}

<br>
== Resolution specification ==

The frequency resolution of the spectrum directly depends on the size of the audio waveform: the longer the waveform, the better the frequency resolution. It is possible, however, to increase the frequency resolution of a given audio waveform by simply adding a series of zeros at the end of the sequence, which is called _zero-padding_. Besides, an optimized version of the Discrete Fourier Transform, called Fast Fourier Transform (FFT) can be performed if the length of the audio waveform (including the zero-padding) is a power of 2. For this reason, by default, a zero-padding is performed by default in order to ensure that the length of the audio waveform is a power of 2. But these operations can be tuned individually:

  * `sig.spectrum(…,'MinRes',`_mr_`)` adds a constraint related to the a minimal frequency resolution, fixed to the value _mr_ (in Hz). The audio waveform is automatically zero-padded to the lowest power of 2 ensuring the required frequency resolution.

  * `sig.spectrum(…,'MinRes',`_r_`,'OctaveRatio',`_tol_`)`: Indicates the minimal accepted resolution in terms of number of divisions of the octave. Low frequencies are ignored in order to reach the desired resolution. The corresponding required frequency resolution is equal to the difference between the first frequency bins, multiplied by the constraining multiplicative factor _tol_ (set by default to .75).

  * `sig.spectrum(…,'Res',`_r_`)` specifies the frequency resolution _r_ (in Hz) that will be secured as closely as possible, through an automated zero-padding. The length of the resulting audio waveform will not necessarily be a power of 2, therefore the FFT routine will rarely be used.

  * `sig.spectrum(…,'Length',`_l_`)` specifies the length of the audio waveform after zero-padding. If the length is not a power of 2, the FFT routine will not be used.

  * `sig.spectrum(…,'ZeroPad',`_s_`)` performs a zero-padding of s samples. If the total length is not a power of 2, the FFT routine will not be used.

  * `sig.spectrum(…,'WarningRes',`_mr_`)` indicates a required frequency resolution, in Hz, for the input signal. If the resolution does not reach that prerequisite, a warning is displayed.

Alternatively, the spectrum decomposition can be performed through a Constant Q Transform instead of a FFT, which enables to express the frequency resolution as a constant number of bins per octave:

  * `sig.spectrum(…,'ConstantQ',`_nb_`)` fixes the number of bins per octave to _nb_. Default value when the `'ConstantQ'` option is toggled on: _nb_ = 12 bins per octave.

Please note however that the Constant Q Transform is implemented as a _Matlab_ M file, whereas _Matlab's_ FFT algorithm is optimized, therefore faster.

<br>

== Post-processing options ==

  * `sig.spectrum(…,'Normal')` normalizes with respect to energy: each magnitude is divided by the euclidian norm (root sum of the squared magnitude). 

  * `sig.spectrum(…,'NormalLength')` normalizes with respect to the duration (in s.) of the audio input data.

  * `sig.spectrum(…,'Power')` squares the energy: each magnitude is squared.

  * `sig.spectrum(…,'dB')` represents the spectrum energy in decibel scale. For the previous example we obtain the following spectrum:<p>

  https://miningsuite.googlecode.com/svn/wiki/SigSpectrum_ex2.png

  * `sig.spectrum(…,'dB',`_th_`)` keeps only the highest energy over a range of _th_ dB. For example if we take only the 20 most highest dB in the previous example we obtain:<p>

  https://miningsuite.googlecode.com/svn/wiki/SigSpectrum_ex3.png

  * `sig.spectrum(…,'Smooth',`_o_`)` smooths the spectrum curve using a moving average of order _o_. Default value when the option is toggled on: _o_ = 10

  * `sig.spectrum(…,'Gauss',`_o_`)` smooths the spectrum curve using a gaussian of standard deviation _o_ samples. Default value when the option is toggled on: _o_ = 10
 
  * `sig.spectrum(…,'TimeSmooth',`_o_`)` smooths each frequency channel of a spectrogram using a moving average of order _o_. Default value when the option is toggled on: _o_ = 10

<br>

== Harmonic spectral analysis ==

A lot of natural sounds, especially musical ones, are harmonic: each sound consists of a series of frequencies at a multiple ratio of the one of lowest frequency, called fundamental. Techniques have been developed in signal processing to reduce each harmonic series to its fundamental, in order to simplify the representation. _MiningSuite_ includes two related techniques for the attenuation of harmonics in spectral representation (Alonso et al, 2003):

  * `sig.spectrum(…,'Prod',`_m_`)` Enhances components that have harmonics located at multiples of range(s) _m_ of the signal's fundamental frequency. Computed by compressing the signal by a list of factors _m_, and by multiplying all the results with the original signal. Default value is _m_ = 1:6. Hence for this initial spectrum:

  https://miningsuite.googlecode.com/svn/wiki/SigSpectrum_ex8.png

we obtain this reduced spectrum:

  https://miningsuite.googlecode.com/svn/wiki/SigSpectrum_ex9.png

  * `sig.spectrum(…,'Sum',`_m_`)` Similar idea using addition of the multiples instead of multiplication.

<br>
== Auditory model ==

Auditory models related spectrum decomposition are available in [AudSpectrum aud.spectrum].

<br>
== Music-theory based model ==

Music-theory transformations related to spectrum decomposition are available in [MusSpectrum mus.spectrum].

<br>
== Accessible Output ==

  * `phase`: the phase associated to each bin,

  * `power`: whether the spectrum has been squared (1) or not (0),

  * `log`: whether the spectrum is in log-scale (1) or in linear scale (0).